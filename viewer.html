<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>X-Plane OBJ8 WebViewer</title>
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <style>
        :root {
            --bg-color: #121212;
            --panel-bg: #1e1e1e;
            --border-color: #333;
            --text-main: #e0e0e0;
            --text-muted: #888;
            --accent: #4db8ff;
            --accent-hover: #6ac4ff;
            --item-hover: #2d2d2d;
            --item-selected: #3a4b5c;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: var(--text-main);
        }

        /* --- SCROLLBARS --- */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--panel-bg);
        }

        ::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* --- LAYOUT --- */
        #app-container {
            display: flex;
            width: 100vw;
            height: 100vh;
        }

        /* --- SIDEBAR (Left) --- */
        #sidebar {
            width: 320px;
            background: var(--panel-bg);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            z-index: 10;
            padding: 15px;
            box-sizing: border-box;
            transition: transform 0.3s;
            user-select: none;
        }

        /* --- MAIN VIEWPORT --- */
        #viewport {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
            background: #0f0f0f;
        }

        /* --- OVERLAY CONTROLS (Right - DataRefs) --- */
        #ui-right-container {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 320px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: none;
            z-index: 20;
        }

        #search-container {
            pointer-events: auto;
            background: var(--panel-bg);
            padding: 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            position: relative;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            flex-shrink: 0;
        }

        #gui-scroll-wrapper {
            pointer-events: auto;
            overflow-y: auto;
            overflow-x: hidden;
            border-radius: 4px;
            max-height: 100%;
        }

        /* --- FLOATING INSPECTOR (Bottom Right) --- */
        #selection-panel {
            position: absolute;
            bottom: 20px;
            right: 350px;
            /* Left of the right UI */
            width: 300px;
            background: rgba(30, 30, 30, 0.95);
            border: 1px solid var(--accent);
            border-radius: 6px;
            padding: 15px;
            display: none;
            flex-direction: column;
            gap: 10px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            z-index: 30;
        }

        #selection-panel.active {
            display: flex;
        }

        #selection-header {
            font-size: 0.85rem;
            text-transform: uppercase;
            color: var(--accent);
            font-weight: bold;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
        }

        .close-selection {
            cursor: pointer;
            color: #aaa;
        }

        .close-selection:hover {
            color: #fff;
        }

        .control-row {
            display: flex;
            flex-direction: column;
            margin-bottom: 8px;
        }

        .control-label {
            font-size: 0.75rem;
            color: #ccc;
            margin-bottom: 4px;
            display: flex;
            justify-content: space-between;
        }

        .control-val {
            color: var(--accent);
            font-family: monospace;
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--accent);
            cursor: pointer;
        }

        /* --- TYPOGRAPHY & ELEMENTS --- */
        h1 {
            margin: 0 0 15px 0;
            font-size: 1rem;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 2px solid var(--accent);
            padding-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h2 {
            margin: 15px 0 8px 0;
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            margin-bottom: 4px;
            color: #bbb;
        }

        .stat-val {
            font-family: monospace;
            color: var(--accent);
        }

        /* --- OBJECT LIST --- */
        #obj-list-wrapper {
            flex-grow: 1;
            /* Takes remaining height */
            min-height: 100px;
            display: flex;
            flex-direction: column;
            margin-bottom: 10px;
        }

        #obj-list-container {
            border: 1px solid var(--border-color);
            background: #161616;
            overflow-y: auto;
            border-radius: 4px;
            flex-grow: 1;
        }

        .obj-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            font-size: 0.8rem;
            border-bottom: 1px solid #252525;
            cursor: pointer;
            transition: background 0.1s;
            color: #666;
            /* Darker default text */
        }

        .obj-item:hover {
            background: var(--item-hover);
            color: #fff;
        }

        /* Hover state from JS (synced with box helper) */
        .obj-item.hover-active {
            background: var(--item-hover);
            color: #fff;
        }

        /* Selected state from clicking mesh or item */
        .obj-item.active-entry {
            background: rgba(255, 255, 255, 0.08);
            /* Much more subtle than var(--item-selected) */
            color: #fff;
            font-weight: 500;
            border-left: 2px solid var(--accent);
        }

        .obj-name {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .icon-btn {
            cursor: pointer;
            width: 20px;
            text-align: center;
            font-weight: bold;
            color: #666;
            user-select: none;
        }

        .icon-btn:hover {
            color: #fff;
        }

        .eye-btn.hidden {
            color: #666;
        }

        .eye-btn:not(.hidden) {
            color: #fff;
        }

        .solo-btn {
            font-size: 0.7rem;
            border: 1px solid #444;
            border-radius: 3px;
            width: 18px;
            height: 18px;
            line-height: 16px;
        }

        .solo-btn.active {
            background: #ffaa00;
            color: #000;
            border-color: #ffaa00;
        }

        /* --- CONTROLS --- */
        .btn {
            background: #2a2a2a;
            color: #eee;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #444;
            cursor: pointer;
            font-weight: 600;
            width: 100%;
            font-size: 0.8rem;
            margin-top: 5px;
            text-align: center;
            transition: 0.2s;
        }

        .btn:hover {
            background: #3a3a3a;
            border-color: var(--accent);
            color: #fff;
        }

        .btn-danger {
            background: #601818;
            border-color: #802020;
            width: auto;
            padding: 4px 8px;
            font-size: 0.7rem;
        }

        .btn-danger:hover {
            background: #902020;
        }

        .chk-label {
            font-size: 0.8rem;
            color: #ccc;
            display: flex;
            align-items: center;
            margin-top: 6px;
            cursor: pointer;
        }

        .chk-label input {
            margin-right: 8px;
            accent-color: var(--accent);
        }

        #view-mode-select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%234db8ff%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
            background-repeat: no-repeat;
            background-position: right 0.7rem top 50%;
            background-size: 0.65rem auto;
            text-align: left;
            padding-left: 10px;
        }

        /* --- SEARCH --- */
        #dref-search {
            width: 100%;
            box-sizing: border-box;
            background: #111;
            border: 1px solid #555;
            color: #fff;
            padding: 8px 30px 8px 10px;
            border-radius: 4px;
            font-size: 0.85rem;
        }

        #dref-search:focus {
            outline: none;
            border-color: var(--accent);
        }

        #search-clear {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: #666;
            cursor: pointer;
            font-weight: bold;
            font-size: 1rem;
        }

        #search-clear:hover {
            color: #fff;
        }

        /* --- UPLOAD --- */
        #upload-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(18, 18, 18, 0.98);
            z-index: 200;
            pointer-events: auto;
            transition: opacity 0.4s;
        }

        #upload-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .drop-box {
            border: 2px dashed #555;
            padding: 50px;
            border-radius: 12px;
            text-align: center;
            color: #888;
            transition: 0.2s;
            background: #222;
        }

        .drop-box:hover {
            border-color: var(--accent);
            color: #fff;
            background: #252525;
        }

        /* Lil GUI Customization */
        .lil-gui {
            width: 100% !important;
            pointer-events: auto;
            --background-color: var(--panel-bg);
            --text-color: #ddd;
            --widget-color: #333;
            --hover-color: #444;
            --name-width: 50%;
        }

        .lil-gui .title {
            display: none;
        }

        .lil-gui .controller {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            padding: 6px 12px !important;
            border-bottom: 1px solid #252525;
            height: auto !important;
        }

        .lil-gui .name {
            width: 100% !important;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding-bottom: 4px;
            order: 1;
            cursor: copy;
            user-select: none;
            font-size: 0.75rem;
            color: var(--accent);
        }

        .lil-gui .widget {
            width: 100% !important;
            height: 26px;
            order: 2;
        }

        /* Notification style for copy */
        .copy-toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--accent);
            color: #000;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: bold;
            z-index: 1000;
            pointer-events: none;
            animation: fadeout 2s forwards;
        }

        @keyframes fadeout {
            0% {
                opacity: 1;
            }

            80% {
                opacity: 1;
            }

            100% {
                opacity: 0;
            }
        }

        /* --- COLLAPSIBLE STATS --- */
        .collapsible-container {
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: #1a1a1a;
            margin-bottom: 10px;
            overflow: hidden;
        }

        .collapsible-header {
            background: #252525;
            padding: 8px 12px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
            font-weight: bold;
            color: var(--accent);
            user-select: none;
        }

        .collapsible-header:hover {
            background: #2d2d2d;
        }

        .collapsible-content {
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .collapsible-content.collapsed {
            display: none;
        }

        #stats-toggle-icon {
            transition: transform 0.2s;
            font-size: 0.7rem;
        }

        .collapsed #stats-toggle-icon {
            transform: rotate(-90deg);
        }

        /* --- VIEWPORT TOOLBAR --- */
        #viewport-toolbar {
            position: absolute;
            top: 15px;
            left: 15px;
            display: flex;
            gap: 6px;
            z-index: 100;
            background: rgba(30, 30, 30, 0.85);
            /* Slightly transparent */
            padding: 6px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(8px);
            align-items: center;
        }

        .icon-btn-tool {
            background: transparent;
            border: 1px solid transparent;
            color: #aaa;
            cursor: pointer;
            min-width: 34px;
            height: 34px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            transition: 0.2s;
            padding: 0 8px;
            font-size: 0.8rem;
            font-weight: 600;
            white-space: nowrap;
        }

        .icon-btn-tool:hover {
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
        }

        .icon-btn-tool.active {
            color: var(--accent);
            border: 1px solid rgba(77, 184, 255, 0.3);
            background: rgba(77, 184, 255, 0.1);
        }

        .icon-btn-tool span {
            font-size: 20px;
        }

        .toolbar-separator {
            width: 1px;
            height: 20px;
            background: #444;
            margin: 0 4px;
        }

        .toolbar-select {
            background: #222;
            color: #eee;
            border: 1px solid #444;
            padding: 0 10px;
            border-radius: 6px;
            height: 34px;
            cursor: pointer;
            outline: none;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .toolbar-select:hover {
            border-color: #666;
        }

        /* --- STATS OVERLAY --- */
        #stats-overlay {
            position: absolute;
            top: 70px;
            /* Below toolbar */
            left: 15px;
            background: rgba(0, 0, 0, 0.0);
            /* Transparent as requested */
            padding: 0;
            pointer-events: none;
            z-index: 90;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .stat-line {
            color: #777;
            font-size: 0.8rem;
            font-family: 'Consolas', monospace;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .stat-line .val {
            color: inherit;
            margin-left: 8px;
        }

        /* --- SETTINGS POPUP --- */
        #settings-popup {
            position: absolute;
            top: 100%;
            /* Below parent */
            left: 0;
            margin-top: 10px;
            background: rgba(25, 25, 25, 0.95);
            border: 1px solid #444;
            padding: 15px;
            border-radius: 8px;
            width: 240px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            z-index: 101;
            transform-origin: top left;
            transition: opacity 0.2s, transform 0.2s;
        }

        #settings-popup.hidden {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.95);
        }

        .popup-section h3 {
            margin: 0 0 8px 0;
            font-size: 0.7rem;
            text-transform: uppercase;
            color: #666;
            border-bottom: 1px solid #333;
            padding-bottom: 4px;
        }

        .popup-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 5px;
            font-size: 0.8rem;
            color: #ccc;
        }

        .popup-row span.material-symbols-outlined {
            font-size: 18px;
            color: #888;
        }

        /* --- LOADING BAR --- */
        #loading-bar-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            background: rgba(30, 30, 30, 0.95);
            border: 1px solid var(--accent);
            border-radius: 8px;
            padding: 20px;
            z-index: 300;
            display: none;
            flex-direction: column;
            gap: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
        }

        #loading-bar-container.active {
            display: flex;
        }

        #loading-bar-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--accent);
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #loading-bar-track {
            width: 100%;
            height: 8px;
            background: #1a1a1a;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        #loading-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--accent-hover));
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        #loading-bar-text {
            font-size: 0.75rem;
            color: #aaa;
            text-align: center;
            font-family: 'Consolas', monospace;
        }

        /* --- VIEWPORT BLUR DURING LOADING --- */
        #viewport.loading {
            filter: blur(8px);
            transition: filter 0.3s ease;
        }

        #branding {
            position: absolute;
            bottom: 10px;
            right: 15px;
            font-size: 0.7rem;
            color: #555;
            pointer-events: none;
            z-index: 100;
            font-family: 'Segoe UI', sans-serif;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
            user-select: none;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.172.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.172.0/examples/jsm/",
                "lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.min.js",
                "three/addons/loaders/DDSLoader.js": "https://unpkg.com/three@0.172.0/examples/jsm/loaders/DDSLoader.js"
            }
        }
    </script>
</head>

<body>

    <div id="app-container">
        <!-- SIDEBAR -->
        <div id="sidebar" class="hidden-ui">
            <h1>OBJ8
                <div style="display:flex; gap:6px;">
                    <label class="btn"
                        style="width: auto; padding: 4px 8px; margin:0; font-size: 0.7rem; display: flex; align-items: center; justify-content: center; cursor: pointer;">
                        <span>Import</span>
                        <input type="file" id="import-input" accept=".obj,.png,.jpg,.jpeg,.bmp,.hdr,.dds" multiple
                            style="display:none">
                    </label>
                    <button class="btn btn-danger" id="clear-btn" name="clear-btn"
                        style="padding: 4px 8px; margin:0; font-size: 0.7rem; width: auto;">Clear</button>
                </div>
            </h1>

            <h2>Objects</h2>
            <div id="obj-list-wrapper">
                <div id="obj-list-container">
                    <!-- Items injected by JS -->
                </div>
            </div>
        </div>

        <!-- MAIN 3D VIEWPORT -->
        <div id="viewport">
            <!-- TOOLBAR -->
            <div id="viewport-toolbar" class="hidden-ui">
                <div class="toolbar-group">
                    <select id="view-mode-select" class="toolbar-select" title="View Mode">
                        <option value="material">Material</option>
                        <option value="solid">Solid</option>
                        <option value="albedo">Albedo</option>
                        <option value="lit_only">Lit Only</option>
                        <option value="normals">Normals</option>
                        <option value="wireframe">Wireframe</option>
                    </select>
                </div>

                <div class="toolbar-separator"></div>

                <button id="recenter-btn" class="icon-btn-tool" title="Recenter Camera"><span
                        class="material-symbols-outlined">center_focus_strong</span></button>
                <button id="toggle-grid-btn" class="icon-btn-tool active" title="Toggle Grid"><span
                        class="material-symbols-outlined">grid_4x4</span></button>
                <button id="toggle-skeleton-btn" class="icon-btn-tool" title="Toggle Pivot Skeleton"><span
                        class="material-symbols-outlined">open_with</span></button>

                <div class="toolbar-separator"></div>

                <div style="position: relative;">
                    <button id="settings-btn" class="icon-btn-tool" title="Settings"><span
                            class="material-symbols-outlined">settings</span></button>
                    <!-- POPUP -->
                    <div id="settings-popup" class="hidden">
                        <div class="popup-section">
                            <h3>Material Defaults</h3>
                            <div class="popup-row">
                                <span class="material-symbols-outlined" title="Roughness">texture</span>
                                <input type="range" id="mat-rough" min="0" max="1" step="0.05" title="Roughness">
                            </div>
                            <div class="popup-row">
                                <span class="material-symbols-outlined" title="Metalness">diamond</span>
                                <input type="range" id="mat-metal" min="0" max="1" step="0.05" title="Metalness">
                            </div>
                            <div class="popup-row">
                                <span class="material-symbols-outlined" title="LIT Intensity">lightbulb</span>
                                <input type="range" id="mat-lit" min="0" max="5" step="0.1" title="LIT Intensity">
                            </div>
                        </div>
                        <div class="popup-section">
                            <h3>Environment</h3>
                            <div class="popup-row">
                                <span class="material-symbols-outlined" title="Exposure">exposure</span>
                                <input type="range" id="cam-exposure" min="0.1" max="2" step="0.1" title="Exposure">
                            </div>
                            <div class="popup-row">
                                <span class="material-symbols-outlined" title="Env Intensity">light_mode</span>
                                <input type="range" id="env-intensity" min="0" max="2" step="0.1" title="Env Intensity">
                            </div>
                            <div class="popup-row">
                                <span class="material-symbols-outlined" title="Env Rotation">360</span>
                                <input type="range" id="env-rotation" min="0" max="360" step="1" title="Env Rotation">
                            </div>
                            <div class="popup-row"><label class="chk-label"><input type="checkbox" id="env-bg-chk"> Show
                                    Background</label></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- STATS -->
            <div id="stats-overlay" class="hidden-ui">
                <div class="stat-line">Verts: <span id="v-count" class="val">0 / 0</span></div>
                <div class="stat-line">Tris: <span id="m-count" class="val">0 / 0</span></div>
                <div class="stat-line">Objects: <span id="o-count" class="val">0 / 0</span></div>
                <div class="stat-line">DataRefs: <span id="d-count" class="val">0</span></div>
                <div class="stat-line">Anims: <span id="a-count" class="val">0</span></div>
            </div>
            <!-- VIEWPORT ACTIONS -->
            <div style="position: absolute; bottom: 20px; left: 20px; z-index: 100; display: flex; gap: 8px;">
                <button id="hide-sel-btn" class="icon-btn-tool"
                    style="width: auto; background: rgba(0,0,0,0.5); border: 1px solid #444;" title="Hide Selected (H)">
                    Hide
                </button>
                <button id="unhide-all-btn" class="icon-btn-tool"
                    style="width: auto; background: rgba(0,0,0,0.5); border: 1px solid #444;"
                    title="Unhide All (Shift+H)">
                    Unhide All
                </button>
            </div>
            <div id="branding">WebViewer by Dreamfoil Creations</div>
        </div>
    </div>

    <!-- FLOATING CONTROLS (Right) -->
    <div id="ui-right-container" class="hidden-ui">
        <div id="search-container">
            <input type="text" id="dref-search" name="dref-search" placeholder="Filter DataRefs..." autocomplete="off"
                aria-label="Filter DataRefs">
            <span id="search-clear">âœ•</span>
        </div>
        <div id="gui-scroll-wrapper">
            <!-- Lil-GUI appends here -->
        </div>
    </div>

    <!-- SELECTION PANEL REMOVED -->

    <!-- UPLOAD SCREEN -->
    <div id="upload-overlay">
        <div class="drop-box" id="drop-target">
            <h2 style="color:#fff; margin-top:0;">X-Plane OBJ8 Viewer</h2>
            <p>Drag & Drop one or multiple .OBJ files</p>
            <label for="file-input" class="btn" style="width: auto; display: inline-block; margin-top:15px;">
                Browse Files
                <input type="file" id="file-input" name="file-input" accept=".obj,.png,.jpg,.jpeg,.bmp,.hdr,.dds"
                    multiple style="display:none">
            </label>
        </div>
    </div>

    <!-- LOADING BAR -->
    <div id="loading-bar-container">
        <div id="loading-bar-title">Loading Assets</div>
        <div id="loading-bar-track">
            <div id="loading-bar-fill"></div>
        </div>
        <div id="loading-bar-text">0 / 0</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { DDSLoader } from 'three/addons/loaders/DDSLoader.js';
        import GUI from 'lil-gui';

        // --- GLOBALS ---
        let scene, camera, renderer, controls, gui;
        let rootGroup, worldGrid, worldAxes;
        let pmremGenerator;
        let raycaster, mouse;
        let lightGroup; // Container for rotatable lights
        let mouseDownPos = { x: 0, y: 0 };

        // Logic Data
        let animationControllers = [];
        let datarefRanges = new Map();
        let guiData = {};
        let guiControllers = [];
        let skeletonHelpers = [];
        let loadedObjects = [];
        let soloObjects = new Set(); // Multi-select Set
        let isShiftDown = false; // Global Shift Tracking
        let isSpaceDown = false; // Global Space Tracking

        // Resources
        let loadedTextures = new Map();
        let materialCache = new Map();
        let selectedMeshes = [];

        // Stats
        let filesLoadedCount = 0;

        // Settings (Defaults)
        const settings = {
            exposure: 1.0,
            rough: 0.5, metal: 0.2, lit: 1.0,
            envIntensity: 0.8,
            rotation: 0,
            showBackground: true
        };

        // Lights
        let headlight, ambientLight, mainLight;
        let currentViewMode = 'material';

        function init() {
            loadSettings();

            const viewport = document.getElementById('viewport');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x121212); // Darker background

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(viewport.clientWidth, viewport.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.AgXToneMapping;
            renderer.toneMappingExposure = settings.exposure;
            viewport.appendChild(renderer.domElement);

            // Raycaster for Selection
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // PBR Environment (Default fallback)
            pmremGenerator = new THREE.PMREMGenerator(renderer);
            scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
            scene.environmentIntensity = settings.envIntensity;
            const rotRad = (settings.rotation || 0) * (Math.PI / 180);
            scene.backgroundRotation.y = rotRad;
            scene.environmentRotation.y = rotRad;

            // Default HDRI loading removed to avoid CORS/404 errors.
            // Users can still drop their own .hdr files.

            // Camera
            camera = new THREE.PerspectiveCamera(45, viewport.clientWidth / viewport.clientHeight, 0.01, 2000);
            camera.position.set(3, 3, 5);
            scene.add(camera);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = false;

            rootGroup = new THREE.Group();
            scene.add(rootGroup);

            // Grid
            worldGrid = new THREE.GridHelper(30, 30, 0x333333, 0x0f0f0f);
            scene.add(worldGrid);
            worldAxes = new THREE.AxesHelper(1);
            scene.add(worldAxes);

            // Improved Studio Lighting Setup
            ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            // Key Light (Main Sun)
            mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
            mainLight.position.set(10, 20, 10);
            scene.add(mainLight);

            // Fill Light
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.6);
            fillLight.position.set(-10, 10, 10);
            scene.add(fillLight);

            // Rim Light (Separation from background)
            const rimLight = new THREE.DirectionalLight(0xffffff, 0.8);
            rimLight.position.set(0, 5, -10);
            scene.add(rimLight);

            // Camera Headlight (Soft Fill that follows camera)
            headlight = new THREE.DirectionalLight(0xffffff, 0.3);
            camera.add(headlight);
            headlight.position.set(1, 1, 1);

            // GUI
            const guiContainer = document.getElementById('gui-scroll-wrapper');
            gui = new GUI({ container: guiContainer, width: '100%' });

            setupDOMControls();

            window.addEventListener('resize', onResize);
            window.addEventListener('keydown', e => {
                if (e.key === 'Shift') isShiftDown = true;
                if (e.code === 'Space' && document.activeElement.tagName !== 'INPUT') {
                    isSpaceDown = true;
                    e.preventDefault();
                }
                if (e.key.toLowerCase() === 'f' && document.activeElement.tagName !== 'INPUT') {
                    centerCamera();
                }
                // Handle hide/unhide shortcuts
                if (e.key.toLowerCase() === 'h' && document.activeElement.tagName !== 'INPUT') {
                    if (e.shiftKey) {
                        unhideAllMeshes();
                    } else {
                        hideSelectedMesh();
                    }
                    e.preventDefault();
                }
            });
            window.addEventListener('keyup', e => {
                if (e.key === 'Shift') isShiftDown = false;
                if (e.code === 'Space') isSpaceDown = false;
            });
            window.addEventListener('blur', () => {
                isShiftDown = false;
                isSpaceDown = false;
            });
            viewport.addEventListener('mousedown', (e) => {
                mouseDownPos.x = e.clientX;
                mouseDownPos.y = e.clientY;
            });
            viewport.addEventListener('click', onClick);

            // File Handling
            const drop = document.getElementById('drop-target');
            window.addEventListener('dragover', e => { e.preventDefault(); drop.style.borderColor = '#4db8ff'; });
            window.addEventListener('dragleave', e => { drop.style.borderColor = '#555'; });
            window.addEventListener('drop', handleDrop);
            document.getElementById('file-input').addEventListener('change', handleFile);

            // Button Logic
            document.getElementById('recenter-btn').addEventListener('click', (e) => { e.stopPropagation(); centerCamera(); });
            document.getElementById('hide-sel-btn').addEventListener('click', (e) => { e.stopPropagation(); hideSelectedMesh(); });
            document.getElementById('unhide-all-btn').addEventListener('click', (e) => { e.stopPropagation(); unhideAllMeshes(); });
            document.getElementById('clear-btn').addEventListener('click', resetViewer);
            document.getElementById('import-input').addEventListener('change', handleFile);
            document.getElementById('dref-search').addEventListener('input', filterDataRefs);
            document.getElementById('search-clear').addEventListener('click', () => {
                document.getElementById('dref-search').value = '';
                filterDataRefs({ target: { value: '' } });
            });
            document.getElementById('view-mode-select').addEventListener('change', (e) => {
                currentViewMode = e.target.value;
                refreshMaterials();
            });

            document.getElementById('stats-overlay').classList.remove('hidden-ui'); // Show stats
            document.getElementById('viewport-toolbar').classList.remove('hidden-ui'); // Show toolbar

            animate();
        }



        // Removed toggleStats as we use always-on overlay
        // function toggleStats() ...

        function loadSettings() {
            const s = localStorage.getItem('xp_obj_viewer_settings');
            if (s) { try { Object.assign(settings, JSON.parse(s)); } catch (e) { } }
        }
        function saveSettings() { localStorage.setItem('xp_obj_viewer_settings', JSON.stringify(settings)); }

        function setupDOMControls() {
            const setVal = (id, val) => {
                const el = document.getElementById(id);
                if (el) el.value = val;
            };
            setVal('mat-rough', settings.rough);
            setVal('mat-metal', settings.metal);
            setVal('mat-lit', settings.lit);
            setVal('cam-exposure', settings.exposure);
            setVal('env-intensity', settings.envIntensity);
            setVal('env-rotation', settings.rotation);

            const bind = (id, fn) => {
                const el = document.getElementById(id);
                if (el) el.addEventListener('input', (e) => { fn(e); saveSettings(); });
            };

            bind('mat-rough', e => { settings.rough = parseFloat(e.target.value); updateMaterialProperties(); });
            bind('mat-metal', e => { settings.metal = parseFloat(e.target.value); updateMaterialProperties(); });
            bind('mat-lit', e => { settings.lit = parseFloat(e.target.value); updateMaterialProperties(); });
            bind('cam-exposure', e => { settings.exposure = parseFloat(e.target.value); renderer.toneMappingExposure = settings.exposure; });
            bind('env-intensity', e => { settings.envIntensity = parseFloat(e.target.value); scene.environmentIntensity = settings.envIntensity; });
            bind('env-rotation', e => {
                settings.rotation = parseFloat(e.target.value);
                const rad = settings.rotation * (Math.PI / 180);
                scene.backgroundRotation.y = rad;
                scene.environmentRotation.y = rad;
            });

            document.getElementById('env-bg-chk').checked = settings.showBackground;
            document.getElementById('env-bg-chk').addEventListener('change', e => {
                settings.showBackground = e.target.checked;
                updateBackground();
                saveSettings();
            });

            // Toolbar Buttons
            const gridBtn = document.getElementById('toggle-grid-btn');
            gridBtn.addEventListener('click', () => {
                worldGrid.visible = !worldGrid.visible;
                worldAxes.visible = worldGrid.visible;
                gridBtn.classList.toggle('active', worldGrid.visible);
            });
            gridBtn.classList.toggle('active', true); // Default on

            const skelBtn = document.getElementById('toggle-skeleton-btn');
            skelBtn.addEventListener('click', () => {
                const vis = !skelBtn.classList.contains('active');
                skelBtn.classList.toggle('active', vis);
                skeletonHelpers.forEach(h => h.visible = vis);
                // Also update logic for unhideAllMeshes references if needed, 
                // but simpler to just use class check primarily or store in a var
            });

            // Settings Popup
            const setBtn = document.getElementById('settings-btn');
            const setPop = document.getElementById('settings-popup');
            setPop.addEventListener('mousedown', (e) => e.stopPropagation()); // Prevent interaction pass-through
            setBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                setPop.classList.toggle('hidden');
                setBtn.classList.toggle('active', !setPop.classList.contains('hidden'));
            });

            // Close popup on click outside
            window.addEventListener('click', (e) => {
                if (!setPop.contains(e.target) && e.target !== setBtn && !setBtn.contains(e.target)) {
                    setPop.classList.add('hidden');
                    setBtn.classList.remove('active');
                }
            });
        }

        function updateBackground() {
            if (settings.showBackground && scene.environment) {
                scene.background = scene.environment;
            } else {
                scene.background = new THREE.Color(0x121212);
            }
        }

        function loadHDRI(url) {
            return new Promise((resolve, reject) => {
                new RGBELoader()
                    .load(url, function (texture) {
                        texture.mapping = THREE.EquirectangularReflectionMapping;
                        if (scene.environment && scene.environment.dispose) scene.environment.dispose();
                        scene.environment = texture;
                        scene.environmentIntensity = settings.envIntensity;
                        updateBackground();
                        resolve(texture);
                    }, undefined, (err) => {
                        console.error("Error loading HDRI:", err);
                        reject(err);
                    });
            });
        }

        function onClick(event) {
            if (event.button !== 0) return; // Left click only

            // Check if we moved significant distance (likely panning)
            const dx = event.clientX - mouseDownPos.x;
            const dy = event.clientY - mouseDownPos.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > 5) return;

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Filter out selection helpers and non-visible meshes from raycasting
            const intersects = raycaster.intersectObjects(rootGroup.children, true).filter(i => {
                if (i.object._isSelectionHelper || i.object.type !== 'Mesh') return false;
                let curr = i.object;
                while (curr && curr !== scene) {
                    if (!curr.visible) return false;
                    curr = curr.parent;
                }
                return true;
            });

            if (intersects.length > 0) {
                // Unique the meshes in intersects to avoid cycling through multiple hits on the same mesh
                const uniqueIntersects = [];
                const seen = new Set();
                for (const hit of intersects) {
                    if (!seen.has(hit.object)) {
                        seen.add(hit.object);
                        uniqueIntersects.push(hit);
                    }
                }

                let meshToSelect = uniqueIntersects[0].object;

                // Cycle logic: if we are clicking and NOT using shift, and the current selection is one of the intersected meshes
                if (!event.shiftKey && selectedMeshes.length === 1) {
                    const currentIdx = uniqueIntersects.findIndex(i => i.object === selectedMeshes[0]);
                    if (currentIdx !== -1) {
                        meshToSelect = uniqueIntersects[(currentIdx + 1) % uniqueIntersects.length].object;
                    }
                }

                selectMesh(meshToSelect, event.shiftKey);
            } else {
                if (!event.shiftKey) deselectMesh();
            }
        }

        function selectMesh(mesh, append = false) {
            if (!append) {
                if (selectedMeshes.length === 1 && selectedMeshes[0] === mesh) {
                    deselectMesh();
                    return;
                }
                deselectMesh();
                selectedMeshes = [mesh];
            } else {
                const idx = selectedMeshes.indexOf(mesh);
                if (idx > -1) {
                    removeHighlight(mesh);
                    selectedMeshes.splice(idx, 1);
                    updateDataRefVisibility();
                    updateStats();
                    updateObjectListSelection();
                    return;
                }
                selectedMeshes.push(mesh);
            }

            addHighlight(mesh);
            updateDataRefVisibility();
            updateStats();
            updateObjectListSelection();
        }

        function addHighlight(mesh) {
            if (mesh._selectionHelper) return;

            // Create an overlay highlight that works in all modes
            const mat = new THREE.MeshBasicMaterial({
                color: 0x4db8ff,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide,
                depthTest: true,
                polygonOffset: true,
                polygonOffsetFactor: -4,
                polygonOffsetUnits: -4
            });

            const helper = new THREE.Mesh(mesh.geometry, mat);
            helper._isSelectionHelper = true;
            mesh.add(helper);
            mesh._selectionHelper = helper;
        }

        function removeHighlight(mesh) {
            if (mesh._selectionHelper) {
                mesh.remove(mesh._selectionHelper);
                if (mesh._selectionHelper.geometry && mesh._selectionHelper.geometry !== mesh.geometry) {
                    mesh._selectionHelper.geometry.dispose();
                }
                if (mesh._selectionHelper.material) {
                    mesh._selectionHelper.material.dispose();
                }
                mesh._selectionHelper = null;
            }
        }

        function deselectMesh() {
            selectedMeshes.forEach(m => removeHighlight(m));
            selectedMeshes = [];
            updateDataRefVisibility();
            updateStats();
            updateObjectListSelection();
        }

        function updateObjectListSelection() {
            // First clear all
            loadedObjects.forEach(rec => rec.div.classList.remove('active-entry'));

            // Find objects involved in selection
            const activeGroups = new Set();
            selectedMeshes.forEach(m => {
                let curr = m;
                while (curr && curr.parent !== rootGroup) {
                    curr = curr.parent;
                }
                if (curr) activeGroups.add(curr);
            });

            loadedObjects.forEach(rec => {
                if (activeGroups.has(rec.group)) {
                    rec.div.classList.add('active-entry');
                    rec.div.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                }
            });
        }

        function hideSelectedMesh() {
            if (selectedMeshes.length > 0) {
                selectedMeshes.forEach(m => m.visible = false);
                deselectMesh();
            }
        }

        function updateVisibility() {
            const showSkeleton = document.getElementById('toggle-skeleton-btn').classList.contains('active');
            const isSoloActive = soloObjects.size > 0;

            // Update Skeletons
            skeletonHelpers.forEach(h => h.visible = showSkeleton);

            // Update Groups based on Solo/Record state
            loadedObjects.forEach(record => {
                let shouldShow = record.visible;
                if (isSoloActive) {
                    shouldShow = soloObjects.has(record);
                }
                record.group.visible = shouldShow;

                // Visual feedback in list
                if (isSoloActive) {
                    record.div.style.opacity = soloObjects.has(record) ? '1' : '0.5';
                } else {
                    record.div.style.opacity = record.visible ? '1' : '0.5';
                }
            });

            updateStats();
        }

        function unhideAllMeshes() {
            // User requested to ONLY unhide meshes (the ones hidden with H), 
            // NOT objects (the ones hidden with the Eye icon or excluded by Solo).

            // 1. Reset all Meshes (in case individual meshes were hidden via 'Hide Selected')
            rootGroup.traverse(o => {
                if (o.isMesh && !o._isSelectionHelper) o.visible = true;
            });

            // 2. Re-apply Object-level visibility (keeps hidden objects hidden)
            updateVisibility();
        }

        function resetViewer() {
            rootGroup.clear();
            skeletonHelpers = [];
            animationControllers = [];
            datarefRanges.clear();
            guiData = {};
            guiControllers = [];
            loadedObjects = [];
            soloObjects.clear();

            materialCache.clear();
            loadedTextures.clear();

            filesLoadedCount = 0;

            document.getElementById('obj-list-container').innerHTML = '';
            document.getElementById('dref-search').value = '';
            deselectMesh();

            if (gui) {
                // Clear all controllers and folders from the GUI
                [...gui.folders].forEach(f => f.destroy());
                [...gui.controllers].forEach(c => c.destroy());
            }

            document.getElementById('upload-overlay').classList.remove('hidden');
            document.getElementById('sidebar').classList.add('hidden-ui');
            document.getElementById('ui-right-container').classList.add('hidden-ui');
            document.getElementById('viewport-toolbar').classList.add('hidden-ui');
            document.getElementById('stats-overlay').classList.add('hidden-ui');
            updateStats();
        }

        function handleDrop(e) {
            e.preventDefault();
            document.getElementById('drop-target').style.borderColor = '#555';
            if (e.dataTransfer.files.length) processFiles(e.dataTransfer.files);
        }
        function handleFile(e) { if (e.target.files.length) processFiles(e.target.files); }

        async function processFiles(files) {
            if (filesLoadedCount === 0) {
                document.getElementById('upload-overlay').classList.add('hidden');
                document.getElementById('sidebar').classList.remove('hidden-ui');
                document.getElementById('ui-right-container').classList.remove('hidden-ui');
            }

            const fileList = Array.from(files);
            const texLoader = new THREE.TextureLoader();
            const ddsLoader = new DDSLoader();

            // Show loading bar
            const loadingContainer = document.getElementById('loading-bar-container');
            const loadingFill = document.getElementById('loading-bar-fill');
            const loadingText = document.getElementById('loading-bar-text');
            const viewport = document.getElementById('viewport');

            loadingContainer.classList.add('active');
            viewport.classList.add('loading');

            // Count total files to load
            const hdrFiles = fileList.filter(f => f.name.toLowerCase().endsWith('.hdr'));
            const imgFiles = fileList.filter(f => /\.(png|jpg|jpeg|bmp|dds)$/i.test(f.name));
            const objFiles = fileList.filter(f => f.name.toLowerCase().endsWith('.obj'));
            const totalFiles = hdrFiles.length + imgFiles.length + objFiles.length;
            let loadedFiles = 0;

            const updateProgress = () => {
                const percent = (loadedFiles / totalFiles) * 100;
                loadingFill.style.width = percent + '%';
                loadingText.textContent = `${loadedFiles} / ${totalFiles}`;
            };

            updateProgress();

            // 0. Process HDRs
            for (const f of hdrFiles) {
                const url = URL.createObjectURL(f);
                await loadHDRI(url);
                URL.revokeObjectURL(url);
                loadedFiles++;
                updateProgress();
            }

            // 1. Identify and load images first
            const texPromises = imgFiles.map(f => {
                return new Promise((resolve) => {
                    const url = URL.createObjectURL(f);
                    const isDDS = f.name.toLowerCase().endsWith('.dds');
                    const loader = isDDS ? ddsLoader : texLoader;

                    loader.load(url, (tex) => {
                        const isNormalMap = f.name.toLowerCase().includes('_nrm');
                        const isMatMap = f.name.toLowerCase().includes('_mat');
                        tex.colorSpace = (isNormalMap || isMatMap) ? THREE.NoColorSpace : THREE.SRGBColorSpace;
                        tex.name = f.name.toLowerCase();

                        if (!isDDS) {
                            // Standard images need flipping to match OpenGL UVs
                            tex.flipY = true;
                            // Enable tiling for standard textures
                            tex.wrapS = THREE.RepeatWrapping;
                            tex.wrapT = THREE.RepeatWrapping;
                        } else {
                            // DDS textures often come in inverted Y compared to WebGL/Three.js expectations
                            // and compressed textures generally don't support .flipY
                            tex.wrapS = THREE.RepeatWrapping;
                            tex.wrapT = THREE.RepeatWrapping;
                            tex.repeat.y = -1;
                            tex.offset.y = 1;
                        }

                        loadedTextures.set(f.name.toLowerCase(), tex);
                        URL.revokeObjectURL(url);
                        loadedFiles++;
                        updateProgress();
                        resolve();
                    }, undefined, (err) => {
                        console.warn(`Error loading texture ${f.name}:`, err);
                        URL.revokeObjectURL(url);
                        loadedFiles++;
                        updateProgress();
                        resolve();
                    });
                });
            });

            await Promise.all(texPromises);

            // 2. Process OBJs
            for (const file of objFiles) {
                const text = await file.text();
                parseOBJ8(text, file.name);
                loadedFiles++;
                updateProgress();
                // Recenter camera after each object is loaded
                centerCamera();
            }

            // 3. Finalize UI and View
            buildGUI();
            refreshMaterials(); // Ensure any newly loaded textures are applied to existing meshes
            updateStats();

            // Hide loading bar, remove blur, and center camera after scene updates
            setTimeout(() => {
                loadingContainer.classList.remove('active');
                viewport.classList.remove('loading');
                centerCamera();
            }, 500);
        }

        // --- PARSER ---
        function parseOBJ8(text, fileName) {

            // Check if object exists and remove it to overwrite
            const existingIdx = loadedObjects.findIndex(o => o.name === fileName);
            if (existingIdx !== -1) {
                const oldRecord = loadedObjects[existingIdx];
                // Remove from scene & solo
                rootGroup.remove(oldRecord.group);

                // Cleanup animations and skeletons for this object
                animationControllers = animationControllers.filter(c => {
                    let curr = c.target;
                    while (curr) {
                        if (curr === oldRecord.group) return false;
                        curr = curr.parent;
                    }
                    return true;
                });

                skeletonHelpers = skeletonHelpers.filter(h => {
                    let curr = h;
                    while (curr) {
                        if (curr === oldRecord.group) return false;
                        curr = curr.parent;
                    }
                    return true;
                });

                if (oldRecord.group.geometry) oldRecord.group.geometry.dispose(); // Group doesn't have geometry but children do
                oldRecord.group.traverse(c => {
                    if (c.geometry) c.geometry.dispose();
                    // if (c.material) c.material.dispose(); // Managed by cache
                });

                // Remove/Replace UI
                // We'll actually just remove the old record and let subsequent code append new one.
                // Ideally we'd replace in place to keep order, but appending is safer for now.
                oldRecord.div.remove();
                loadedObjects.splice(existingIdx, 1);
                soloObjects.delete(oldRecord);
            } else {
                filesLoadedCount++;
            }

            const fileGroup = new THREE.Group();
            fileGroup.name = fileName;
            rootGroup.add(fileGroup);

            // Register for List
            registerObjectUI(fileName, fileGroup);

            const vertices = [];
            const indices = [];
            const lines = text.split(/\r?\n/);

            let currentTexture = "default";
            let litTexture = null;
            let normalTexture = null;
            // Pre-scan texture(s)
            for (let i = 0; i < Math.min(lines.length, 100); i++) {
                const l = lines[i].split('#')[0].trim();
                const parts = l.split(/\s+/);
                if (parts[0] === 'TEXTURE') { currentTexture = parts[1]; }
                if (parts[0] === 'TEXTURE_LIT') { litTexture = parts[1]; }
                if (parts[0] === 'TEXTURE_NORMAL') { normalTexture = parts[1]; }
            }

            const groupStack = [{ object: fileGroup }];
            const currentGroup = () => groupStack[groupStack.length - 1].object;
            let currentAnimKey = null;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].split('#')[0].trim();
                if (!line) continue;
                const tokens = line.split(/\s+/).filter(t => t.length > 0);
                const cmd = tokens[0];

                try {
                    if (cmd === 'VT') {
                        vertices.push({
                            x: parseFloat(tokens[1]) || 0, y: parseFloat(tokens[2]) || 0, z: parseFloat(tokens[3]) || 0,
                            nx: parseFloat(tokens[4]) || 0, ny: parseFloat(tokens[5]) || 0, nz: parseFloat(tokens[6]) || 0,
                            u: parseFloat(tokens[7]) || 0, v: parseFloat(tokens[8]) || 0
                        });
                    }
                    else if (cmd.startsWith('IDX')) {
                        for (let j = 1; j < tokens.length; j++) indices.push(parseInt(tokens[j]));
                    }
                    else if (cmd === 'TRIS') {
                        createMesh(tokens, vertices, indices, currentGroup, currentTexture, litTexture, normalTexture);
                    }
                    else if (cmd === 'ANIM_begin') {
                        const g = new THREE.Group();
                        currentGroup().add(g);
                        groupStack.push({ object: g });
                    }
                    else if (cmd === 'ANIM_end') {
                        if (groupStack.length > 1) groupStack.pop();
                    }
                    else if (cmd === 'ANIM_trans') {
                        // ALWAYS APPLY STATIC TRANSFORMS
                        let isStatic = false;
                        if (tokens.length <= 4) isStatic = true;
                        else if (tokens.length >= 7 && !isNaN(parseFloat(tokens[6]))) {
                            const x1 = parseFloat(tokens[1]), x2 = parseFloat(tokens[4]);
                            if (Math.abs(x1 - x2) < 0.0001) isStatic = true;
                        }

                        if (isStatic) {
                            const wrapper = createWrapperGroup(groupStack);
                            let x = 0, y = 0, z = 0;
                            if (tokens.length >= 4) { x = parseFloat(tokens[1]); y = parseFloat(tokens[2]); z = parseFloat(tokens[3]); }
                            wrapper.position.set(x, y, z);
                            addSkeletonHelper(wrapper, 0xffff00, 0.05);
                        } else {
                            const wrapper = createWrapperGroup(groupStack);
                            const dref = tokens[tokens.length - 1];
                            const v1 = parseFloat(tokens[7]), v2 = parseFloat(tokens[8]);
                            const p1 = new THREE.Vector3(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3]));
                            const p2 = new THREE.Vector3(parseFloat(tokens[4]), parseFloat(tokens[5]), parseFloat(tokens[6]));
                            registerDataRef(dref, v1, v2);
                            animationControllers.push({ type: 'translate', target: wrapper, dref: dref, keys: [{ val: v1, pos: p1 }, { val: v2, pos: p2 }] });
                            addSkeletonHelper(wrapper, 0x00ff00, 0.1);
                        }
                    }
                    else if (cmd === 'ANIM_rotate') {
                        const lastToken = tokens[tokens.length - 1];
                        const isStatic = !isNaN(parseFloat(lastToken));
                        const axis = new THREE.Vector3(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3])).normalize();

                        if (isStatic) {
                            const wrapper = createWrapperGroup(groupStack);
                            const angle = parseFloat(tokens[4]);
                            wrapper.quaternion.setFromAxisAngle(axis, angle * (Math.PI / 180));
                            addSkeletonHelper(wrapper, 0xffaa00, 0.05);
                        } else {
                            const wrapper = createWrapperGroup(groupStack);
                            const dref = tokens[8];
                            const v1 = parseFloat(tokens[6]), v2 = parseFloat(tokens[7]);
                            registerDataRef(dref, v1, v2);
                            animationControllers.push({ type: 'rotate', target: wrapper, dref: dref, axis: axis, keys: [{ val: v1, angle: parseFloat(tokens[4]) }, { val: v2, angle: parseFloat(tokens[5]) }] });
                            addSkeletonHelper(wrapper, 0xff0000, 0.1);
                        }
                    }
                    else if (cmd === 'ANIM_hide' || cmd === 'ANIM_show') {
                        // Standard hide/show: v1 v2 dref
                        // If dref value is between v1 and v2, object is Hidden (ANIM_hide) or Shown (ANIM_show)
                        const wrapper = createWrapperGroup(groupStack);
                        const v1 = parseFloat(tokens[1]);
                        const v2 = parseFloat(tokens[2]);
                        const dref = tokens[3];
                        registerDataRef(dref, v1, v2);
                        animationControllers.push({
                            type: cmd === 'ANIM_hide' ? 'hide' : 'show',
                            target: wrapper,
                            dref: dref,
                            min: v1,
                            max: v2
                        });
                        addSkeletonHelper(wrapper, 0x555555, 0.05);
                    }
                    else if (cmd === 'ANIM_trans_begin') {
                        const dref = tokens[1]; // Might be undefined
                        currentAnimKey = {
                            type: 'translate',
                            dref: dref,
                            isStatic: !dref, // Flag as static if no DataRef
                            keys: [],
                            group: createWrapperGroup(groupStack)
                        };
                    }
                    else if (cmd === 'ANIM_rotate_begin') {
                        const axis = new THREE.Vector3(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3])).normalize();
                        const dref = tokens[4]; // Might be undefined
                        currentAnimKey = {
                            type: 'rotate',
                            dref: dref,
                            axis: axis,
                            isStatic: !dref, // Flag as static if no DataRef
                            keys: [],
                            group: createWrapperGroup(groupStack)
                        };
                        addSkeletonHelper(currentAnimKey.group, 0xff00ff, 0.1);
                    }
                    else if (cmd.endsWith('_key')) {
                        if (currentAnimKey) {
                            const val = parseFloat(tokens[1]);
                            // Only register DataRef if it exists (not static)
                            if (!currentAnimKey.isStatic) {
                                registerDataRef(currentAnimKey.dref, val);
                            }

                            if (currentAnimKey.type === 'translate') {
                                currentAnimKey.keys.push({
                                    val: val,
                                    pos: new THREE.Vector3(parseFloat(tokens[2]), parseFloat(tokens[3]), parseFloat(tokens[4]))
                                });
                            } else {
                                currentAnimKey.keys.push({
                                    val: val,
                                    angle: parseFloat(tokens[2])
                                });
                            }
                        }
                    }
                    else if (cmd.endsWith('_end')) {
                        if (currentAnimKey) {
                            if (currentAnimKey.isStatic) {
                                // STATIC: Calculate transform for default value 0 and apply immediately
                                // We assume input is 0 (standard default for un-driven animations)
                                const staticVal = interpolate(0, currentAnimKey.keys);

                                if (staticVal !== null) {
                                    if (currentAnimKey.type === 'translate') {
                                        currentAnimKey.group.position.copy(staticVal);
                                    } else if (currentAnimKey.type === 'rotate') {
                                        currentAnimKey.group.quaternion.setFromAxisAngle(
                                            currentAnimKey.axis,
                                            staticVal * (Math.PI / 180)
                                        );
                                    }
                                }
                                // We do NOT push to animationControllers, so it won't appear in the list
                            } else {
                                // DYNAMIC: Push to controllers
                                animationControllers.push({
                                    type: currentAnimKey.type,
                                    target: currentAnimKey.group,
                                    dref: currentAnimKey.dref,
                                    axis: currentAnimKey.axis,
                                    keys: currentAnimKey.keys
                                });
                            }
                            currentAnimKey = null;
                        }
                    }
                } catch (e) {
                    console.warn(`[OBJ8 Parser] Error in ${fileName} at line ${i + 1}: "${line}"`, e);
                }
            }
        }

        // --- MESH GENERATION ---
        function createMesh(tokens, vertices, indices, currentGroup, texName, litName, normName) {
            const offset = parseInt(tokens[1]);
            const count = parseInt(tokens[2]);
            const geo = new THREE.BufferGeometry();
            const pos = [], norm = [], uv = [];

            for (let k = 0; k < count; k++) {
                let vIdx = offset + k;
                if (indices.length > 0) vIdx = (vIdx < indices.length) ? indices[vIdx] : 0;
                if (vIdx < vertices.length) {
                    const v = vertices[vIdx];
                    pos.push(v.x, v.y, v.z);
                    norm.push(v.nx, v.ny, v.nz);
                    uv.push(v.u, v.v);
                }
            }
            if (pos.length > 0) {
                geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                geo.setAttribute('normal', new THREE.Float32BufferAttribute(norm, 3));
                geo.setAttribute('uv', new THREE.Float32BufferAttribute(uv, 2));

                // computeTangents requires position, normal, and uv. 
                // It also works better on indexed geometry.
                if (pos.length / 3 > 0) {
                    const tempIndices = [];
                    for (let n = 0; n < pos.length / 3; n++) tempIndices.push(n);
                    geo.setIndex(tempIndices);
                    geo.computeTangents();
                }

                const mat = getMaterial(texName, litName, normName);
                const mesh = new THREE.Mesh(geo, mat);
                mesh._textureName = texName;
                mesh._litName = litName;
                mesh._normalName = normName;
                // Shadows removed
                currentGroup().add(mesh);
            }
        }

        function registerObjectUI(name, group) {
            const container = document.getElementById('obj-list-container');
            const div = document.createElement('div');
            div.className = 'obj-item';

            const nameSpan = document.createElement('span');
            nameSpan.className = 'obj-name';
            nameSpan.title = name;
            nameSpan.textContent = name;

            const eye = document.createElement('span');
            eye.className = 'icon-btn eye-btn material-symbols-outlined';
            eye.textContent = 'visibility';
            eye.style.fontSize = '18px';

            const solo = document.createElement('span');
            solo.className = 'icon-btn solo-btn';
            solo.textContent = 'S';
            solo.title = 'Solo Object';

            const objRecord = { name, group, visible: true, div, eye, solo, datarefs: new Set() };
            loadedObjects.push(objRecord);

            // Toggle Visibility
            eye.onclick = (e) => {
                e.stopPropagation();
                if (soloObjects.size > 0) return; // Disable toggle when solo is active (simplifies logic)
                objRecord.visible = !objRecord.visible;
                group.visible = objRecord.visible;

                eye.textContent = objRecord.visible ? 'visibility' : 'visibility_off';
                eye.classList.toggle('hidden', !objRecord.visible);
                div.style.opacity = objRecord.visible ? '1' : '0.5';
                updateStats();
                updateDataRefVisibility();
            };

            // Solo Mode
            solo.onclick = (e) => {
                e.stopPropagation();

                // Toggle Solo Membership
                if (soloObjects.has(objRecord)) {
                    soloObjects.delete(objRecord);
                    solo.classList.remove('active');
                } else {
                    soloObjects.add(objRecord);
                    solo.classList.add('active');
                }

                updateVisibility(); // This function now handles Applying Visibility based on state
                updateDataRefVisibility();
            };

            // Hover Highlight
            let boxHelper = null;
            div.onmouseenter = () => {
                div.classList.add('hover-active');
                boxHelper = new THREE.BoxHelper(group, 0xffff00);
                scene.add(boxHelper);
            };
            div.onmouseleave = () => {
                div.classList.remove('hover-active');
                if (boxHelper) scene.remove(boxHelper);
                boxHelper = null;
            };

            div.appendChild(nameSpan);
            div.appendChild(solo);
            div.appendChild(eye);
            container.appendChild(div);
        }

        // --- DATAREFS ---
        function registerDataRef(name, ...values) {
            if (!name) return;
            // Record in the most recently added object (the one currently being parsed)
            if (loadedObjects.length > 0) {
                loadedObjects[loadedObjects.length - 1].datarefs.add(name);
            }

            let entry = datarefRanges.get(name);
            if (!entry) { entry = { min: Infinity, max: -Infinity }; datarefRanges.set(name, entry); }
            values.forEach(v => {
                if (v < entry.min) entry.min = v;
                if (v > entry.max) entry.max = v;
            });
        }

        function buildGUI() {
            // Instead of destroying everything, we rebuild the list properly
            // Clear existing UI references but keep guiData for state persistence
            [...gui.folders].forEach(f => f.destroy());
            [...gui.controllers].forEach(c => c.destroy());
            guiControllers = [];

            // Calculate Usage Counts (by number of meshes affected)
            const drefCounts = {};
            animationControllers.forEach(c => {
                if (c.dref) {
                    let meshCount = 0;
                    c.target.traverse(obj => {
                        if (obj.isMesh && !obj._isSelectionHelper) meshCount++;
                    });
                    drefCounts[c.dref] = (drefCounts[c.dref] || 0) + meshCount;
                }
            });

            const sortedKeys = Array.from(datarefRanges.keys()).sort();
            sortedKeys.forEach(name => {
                const range = datarefRanges.get(name);
                let min = range.min, max = range.max;
                let span = max - min;
                if (span === 0) span = 1;
                const margin = span * 0.05; // 10% total (5% each side)
                min -= margin; max += margin;

                // Ensure 0 is included in the range
                if (0 < min) min = -0.5;
                if (0 > max) max = 0.5;

                // 1. Collect Keyframes per DataRef
                const drefKeys = new Map();
                animationControllers.forEach(ctrl => {
                    if (ctrl.dref && ctrl.keys) {
                        if (!drefKeys.has(ctrl.dref)) drefKeys.set(ctrl.dref, new Set());
                        ctrl.keys.forEach(k => drefKeys.get(ctrl.dref).add(k.val));
                    }
                    // Also hide/show limits
                    if (ctrl.dref && (ctrl.type === 'hide' || ctrl.type === 'show')) {
                        if (!drefKeys.has(ctrl.dref)) drefKeys.set(ctrl.dref, new Set());
                        drefKeys.get(ctrl.dref).add(ctrl.min); // start
                        drefKeys.get(ctrl.dref).add(ctrl.max); // end
                    }
                });

                if (guiData[name] === undefined) {
                    guiData[name] = 0;
                }

                // Create Controller
                const ctrl = gui.add(guiData, name, min, max).name(name).listen();

                // Keyframe Snapping & Ticks
                const keys = drefKeys.has(name) ? Array.from(drefKeys.get(name)) : [];
                if (!keys.includes(0)) keys.push(0); // Ensure 0 is always a tick
                keys.sort((a, b) => a - b);

                // Inject Ticks
                if (keys.length > 0) {
                    // Wait for DOM to be ready
                    setTimeout(() => {
                        const widget = ctrl.domElement.querySelector('.widget');
                        const slider = widget ? widget.querySelector('.slider') : null;
                        if (slider) {
                            slider.style.position = 'relative'; // Ensure relative context
                            keys.forEach(k => {
                                // Calculate percent
                                const updateTick = (el, val) => {
                                    const currMin = ctrl._min;
                                    const currMax = ctrl._max;
                                    const pct = (val - currMin) / (currMax - currMin) * 100;
                                    el.style.left = pct + '%';
                                    el.style.display = (pct >= 0 && pct <= 100) ? 'block' : 'none';
                                };

                                const tick = document.createElement('div');
                                tick.style.position = 'absolute';
                                tick.style.top = '0';
                                tick.style.bottom = '0';
                                tick.style.width = '1px';
                                tick.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
                                tick.style.pointerEvents = 'none';
                                slider.appendChild(tick);

                                updateTick(tick, k);
                                // Attach update logic to controller so we can call it if range changes
                                if (!ctrl._ticks) ctrl._ticks = [];
                                ctrl._ticks.push({ el: tick, val: k });
                            });
                        }
                    }, 0);
                }

                // Snap Logic
                let isSnapping = false;
                ctrl.onChange(val => {
                    if (isSnapping) return;

                    // Disable snapping if manually typing (input is focused)
                    const input = ctrl.domElement.querySelector('input');
                    if (input === document.activeElement) return;

                    if (!isShiftDown && keys.length > 0) {
                        // Find nearest
                        let nearest = keys[0];
                        let minDiff = Math.abs(val - keys[0]);
                        for (let i = 1; i < keys.length; i++) {
                            const d = Math.abs(val - keys[i]);
                            if (d < minDiff) { minDiff = d; nearest = keys[i]; }
                        }

                        // Snap threshold: 2% of range
                        const threshold = (ctrl._max - ctrl._min) * 0.02;
                        if (minDiff < threshold) {
                            isSnapping = true;
                            ctrl.setValue(nearest);
                            isSnapping = false;
                            val = nearest;
                        }
                    }
                });

                // Allow out-of-bounds input values
                setTimeout(() => {
                    const input = ctrl.domElement.querySelector('input');
                    if (input) {
                        let rawInput = input.value;
                        input.addEventListener('input', (e) => { rawInput = e.target.value; });
                        input.addEventListener('change', () => {
                            const val = parseFloat(rawInput);
                            if (!isNaN(val)) {
                                guiData[name] = val;
                                ctrl.updateDisplay();
                            }
                        });
                    }
                }, 10);



                // Add click-to-copy
                setTimeout(() => {
                    const label = ctrl.domElement.querySelector('.name');
                    if (label) {
                        label.addEventListener('dblclick', (e) => {
                            e.stopPropagation();
                            navigator.clipboard.writeText(name);
                            showToast(`Copied: ${name}`);
                        });
                    }
                    const inputs = ctrl.domElement.querySelectorAll('input, select');
                    inputs.forEach((input, idx) => {
                        if (!input.name) input.name = name;
                        if (!input.id) input.id = 'gui-' + name.replace(/\W/g, '-');
                    });
                }, 10);

                guiControllers.push({ name: name, controller: ctrl, count: (drefCounts[name] || 0) });
            });

            // Re-apply filter immediately after rebuild
            const searchVal = document.getElementById('dref-search').value;
            filterDataRefs({ target: { value: searchVal } });
        }

        function interpolate(val, keys) {
            if (keys.length === 0) return null;
            const first = keys[0];
            const last = keys[keys.length - 1];
            if (keys.length === 1) return first.pos ? first.pos.clone() : first.angle;

            let k1, k2;
            const isIncreasing = first.val < last.val;

            if (isIncreasing) {
                if (val <= first.val) {
                    k1 = keys[0]; k2 = keys[1];
                } else if (val >= last.val) {
                    k1 = keys[keys.length - 2]; k2 = keys[keys.length - 1];
                } else {
                    for (let i = 0; i < keys.length - 1; i++) {
                        if (val >= keys[i].val && val <= keys[i + 1].val) {
                            k1 = keys[i]; k2 = keys[i + 1]; break;
                        }
                    }
                }
            } else {
                if (val >= first.val) {
                    k1 = keys[0]; k2 = keys[1];
                } else if (val <= last.val) {
                    k1 = keys[keys.length - 2]; k2 = keys[keys.length - 1];
                } else {
                    for (let i = 0; i < keys.length - 1; i++) {
                        if (val <= keys[i].val && val >= keys[i + 1].val) {
                            k1 = keys[i]; k2 = keys[i + 1]; break;
                        }
                    }
                }
            }

            if (!k1 || !k2) return first.pos ? first.pos.clone() : first.angle;

            const t = (val - k1.val) / (k2.val - k1.val);
            if (k1.pos) return new THREE.Vector3().copy(k1.pos).lerp(k2.pos, t);
            return k1.angle + (k2.angle - k1.angle) * t;
        }

        function createWrapperGroup(stack) {
            const currentLevel = stack[stack.length - 1];
            const parent = currentLevel.object;
            const wrapper = new THREE.Group();
            parent.add(wrapper);
            currentLevel.object = wrapper;
            return wrapper;
        }

        function getMaterial(textureName, litName, normalName) {
            const baseName = textureName ? textureName.split(/[/\\]/).pop() : "default";
            const litBase = litName ? litName.split(/[/\\]/).pop() : null;
            const normBase = normalName ? normalName.split(/[/\\]/).pop() : null;
            // Removed settings from cacheKey to allow property updates without cache invalidation
            const cacheKey = `${baseName}|${litBase}|${normBase}|${currentViewMode}`;

            if (!materialCache.has(cacheKey)) {
                let mat;
                if (currentViewMode === 'albedo') {
                    mat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
                } else if (currentViewMode === 'lit_only') {
                    mat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
                } else if (currentViewMode === 'normals') {
                    mat = new THREE.MeshNormalMaterial({ side: THREE.DoubleSide });
                } else {
                    mat = new THREE.MeshStandardMaterial({
                        name: baseName,
                        color: 0xbbbbbb, side: THREE.DoubleSide,
                        roughness: settings.rough, metalness: settings.metal
                    });
                    if (currentViewMode === 'wireframe') mat.wireframe = true;
                }

                const findTex = (name) => {
                    if (!name || name === "default") return null;
                    const low = name.toLowerCase();
                    const candidates = [
                        low,
                        low + ".png", low + ".jpg", low + ".jpeg", low + ".bmp", low + ".dds",
                        low.replace(/\.[^/.]+$/, "") + ".png",
                        low.replace(/\.[^/.]+$/, "") + ".jpg",
                        low.replace(/\.[^/.]+$/, "") + ".dds"
                    ];
                    for (const c of candidates) {
                        if (loadedTextures.has(c)) return loadedTextures.get(c);
                    }
                    return null;
                };

                // Shared Material Logic for Material, Solid, and Wireframe
                if (currentViewMode === 'material' || currentViewMode === 'solid' || currentViewMode === 'wireframe') {
                    // 1. Albedo & Lit (Only in material mode)
                    if (currentViewMode === 'material') {
                        const tex = findTex(baseName);
                        if (tex) { mat.map = tex; mat.color.set(0xffffff); }

                        const ltex = findTex(litBase);
                        if (ltex) { mat.emissiveMap = ltex; mat.emissive.set(0xffffff); mat.emissiveIntensity = settings.lit; }
                    } else {
                        mat.color.set(0x888888);
                    }

                    // 2. Normals (Available in Solid and Material)
                    let rootName = baseName.replace(/\.[^/.]+$/, "").replace(/_alb$/i, "");
                    let ntex = findTex(normBase);
                    if (!ntex) ntex = findTex(rootName + "_NRM") || findTex(rootName + "_nrm");
                    if (ntex) {
                        mat.normalMap = ntex;
                        mat.normalScale.set(1, 1);
                        // X-Plane normal maps use R and G channels for normal vector
                        ntex.colorSpace = THREE.NoColorSpace;
                        ntex.channel = 0; // R channel
                    }

                    // 3. PBR Maps (MAT)
                    // X-Plane MAT format: R=Metalness, G=Roughness, B=AO
                    const mtex = findTex(rootName + "_MAT") || findTex(rootName + "_mat");
                    if (mtex) {
                        // Create separate texture references for each channel
                        const metalTex = mtex.clone();
                        const roughTex = mtex.clone();
                        //const aoTex = mtex.clone();

                        // Assign correct channels (0=R, 1=G, 2=B)
                        metalTex.channel = 0; // Red = Metalness
                        roughTex.channel = 1; // Green = Roughness
                        //aoTex.channel = 2;    // Blue = AO

                        mat.metalnessMap = metalTex;
                        mat.roughnessMap = roughTex;
                        //mat.aoMap = aoTex;

                        // Set factors to 1.0 to use texture values directly
                        mat.metalness = 1.0;
                        mat.roughness = 1.0;
                        //mat.aoMapIntensity = 1.0;

                        // Ensure textures need update
                        metalTex.needsUpdate = true;
                        roughTex.needsUpdate = true;
                        //aoTex.needsUpdate = true;
                    }
                } else if (currentViewMode === 'albedo') {
                    const tex = findTex(baseName);
                    if (tex) mat.map = tex;
                } else if (currentViewMode === 'lit_only') {
                    const ltex = findTex(litBase);
                    if (ltex) mat.map = ltex; else mat.color.set(0x000000);
                }

                materialCache.set(cacheKey, mat);
            }
            return materialCache.get(cacheKey);
        }

        function updateMaterialProperties() {
            // Efficiently update existing materials without rebuilding them
            // This assumes all materials in cache are active or valid
            materialCache.forEach(mat => {
                // Shared logic for Material/Standard modes
                if (mat.isMeshStandardMaterial) {
                    // Update LIT intensity if map exists
                    if (mat.emissiveMap) {
                        mat.emissiveIntensity = settings.lit;
                    }

                    // Update Roughness/Metalness ONLY if no maps are defining them
                    // (Matches logic in getMaterial where we set to 1.0 if map exists)
                    if (!mat.roughnessMap) {
                        mat.roughness = settings.rough;
                    }
                    if (!mat.metalnessMap) {
                        mat.metalness = settings.metal;
                    }
                }
            });
        }

        function refreshMaterials() {
            // Clear cache so we really fetch potentially new textures
            materialCache.clear();
            rootGroup.traverse(obj => {
                if (obj.isMesh && !obj._isSelectionHelper) {
                    const t = obj._textureName, l = obj._litName, n = obj._normalName;
                    obj.material = getMaterial(t, l, n);
                }
            });
        }

        function addSkeletonHelper(group, color, size) {
            const axes = new THREE.AxesHelper(size);
            group.add(axes);
            const visible = document.getElementById('toggle-skeleton-btn').classList.contains('active');
            axes.visible = visible;
            skeletonHelpers.push(axes);
        }

        function updateStats(group = null) {
            let vTotal = 0, tTotal = 0;
            let vSel = 0, tSel = 0;
            let oTotal = 0, oSel = 0;

            let dRefs = new Set();
            let aCount = 0;

            if (group) {
                // Stats for specific object/group override? 
                // User asked for "Selected / Total". 
                // Hover stats might just show that object's stats?
                // Let's stick to global stats for now to meet the "like Blender" requirement 
                // but maybe we can just compute global here every time.
            }

            // 1. Calculate Visible Totals
            loadedObjects.forEach(obj => {
                if (obj.group.visible) {
                    oTotal++;
                    obj.group.traverse(o => {
                        if (o.isMesh && !o._isSelectionHelper) {
                            vTotal += o.geometry.attributes.position.count;
                            if (o.geometry.index) {
                                tTotal += o.geometry.index.count / 3;
                            } else {
                                tTotal += o.geometry.attributes.position.count / 3;
                            }
                        }
                    });
                }
            });

            // 2. Calculate Selected Totals
            if (selectedMeshes.length > 0) {
                // Count unique top-level objects selected
                let uniqueSelObjs = new Set();
                selectedMeshes.forEach(m => {
                    let curr = m;
                    // Traverse up to find the root object (child of rootGroup)
                    while (curr && curr.parent !== rootGroup) {
                        curr = curr.parent;
                    }
                    if (curr && curr.name) { // Ensure it's one of our loaded objects
                        uniqueSelObjs.add(curr);
                    }
                });

                oSel = uniqueSelObjs.size;

                // For verts/tris, we still sum up the actual selected MESHES because in Object Mode in Blender, 
                // selecting an object implies selecting all its geometry stats. 
                // However, our selection is mesh-based (raycast).
                // If the user wants "Object" stats, we should probably verify if we are in "Object Mode" or "Edit Mode" equivalent.
                // Assuming "Object Mode" equivalent: 
                // If I select a mesh part of an airplane, I probably consider the "Airplane" selected?
                // Or does the user mean "only the vertices of the selected mesh"?
                // "Stats should display the selected mesh not object" -> likely means specific mesh stats.
                // BUT "Stats should display the selected mesh not object" implies counting the mesh itself?
                // Wait, "Selected / Total" usually refers to Object count.
                // Let's stick to summing selected mesh geometry for V/T, and top-level objects for O.

                selectedMeshes.forEach(m => {
                    vSel += m.geometry.attributes.position.count;
                    if (m.geometry.index) {
                        tSel += m.geometry.index.count / 3;
                    } else {
                        tSel += m.geometry.attributes.position.count / 3;
                    }
                });
            }

            // 3. DataRefs and Anims (Global)
            animationControllers.forEach(ctrl => {
                aCount++;
                if (ctrl.dref) dRefs.add(ctrl.dref);
            });

            const format = (n) => n.toLocaleString();

            document.getElementById('v-count').innerText = `${format(vSel)} / ${format(vTotal)}`;
            document.getElementById('m-count').innerText = `${format(tSel)} / ${format(tTotal)}`;
            document.getElementById('o-count').innerText = `${format(oSel)} / ${format(oTotal)}`;
            document.getElementById('d-count').innerText = format(dRefs.size);
            document.getElementById('a-count').innerText = format(aCount);
        }

        function centerCamera() {
            if (rootGroup.children.length === 0) return;

            // Force update of all world matrices before computing bounds
            rootGroup.updateMatrixWorld(true);

            const box = new THREE.Box3();
            let hasBounds = false;

            if (selectedMeshes.length > 0) {
                // Center on selection
                selectedMeshes.forEach(m => {
                    m.geometry.computeBoundingBox();
                    const b = new THREE.Box3().copy(m.geometry.boundingBox).applyMatrix4(m.matrixWorld);
                    box.union(b);
                });
                hasBounds = true;
            } else {
                // Center on all visible meshes (excluding selection helpers)
                rootGroup.traverse(obj => {
                    if (obj.isMesh && !obj._isSelectionHelper) {
                        // Check if object and all ancestors (up to rootGroup) are visible
                        let curr = obj;
                        let visible = true;
                        while (curr && curr !== scene) {
                            if (!curr.visible) {
                                visible = false;
                                break;
                            }
                            curr = curr.parent;
                        }

                        if (visible) {
                            obj.geometry.computeBoundingBox();
                            const meshBox = new THREE.Box3().copy(obj.geometry.boundingBox).applyMatrix4(obj.matrixWorld);
                            box.union(meshBox);
                            hasBounds = true;
                        }
                    }
                });
            }

            if (!hasBounds || box.isEmpty()) return;

            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());

            // Calculate distance needed to fit the box in both horizontal and vertical FOV
            const maxDim = Math.max(size.x, size.y, size.z);
            if (isNaN(maxDim) || maxDim <= 0) return;

            // Account for both vertical and horizontal FOV
            const fov = camera.fov * (Math.PI / 180);
            const aspect = camera.aspect;

            // Calculate required distance for vertical FOV
            const distanceV = (size.y / 2) / Math.tan(fov / 2);

            // Calculate required distance for horizontal FOV
            const fovH = 2 * Math.atan(Math.tan(fov / 2) * aspect);
            const distanceH = (size.x / 2) / Math.tan(fovH / 2);

            // Use the larger distance to ensure everything fits
            let distance = Math.max(distanceV, distanceH, size.z / 2);

            // Add 40% padding for better framing with more margin
            distance *= 1.4;

            // Ensure minimum distance
            distance = Math.max(distance, 0.5);

            // Preserve current orientation relative to the new target
            const currentDir = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();

            // If currentDir is zero length (e.g. camera inside target), fallback to default
            if (currentDir.lengthSq() < 0.0001) {
                currentDir.set(1, 0.8, 1).normalize();
            }

            const offset = currentDir.multiplyScalar(distance);
            camera.position.copy(center).add(offset);

            controls.target.copy(center);
            controls.update();
        }

        function filterDataRefs(e) {
            updateDataRefVisibility();
        }

        function updateDataRefVisibility() {
            const term = document.getElementById('dref-search').value.toLowerCase();

            // Determine active datarefs based on visibility AND potential selection
            const activeDatarefs = new Set();

            if (selectedMeshes.length > 0) {
                // Only show datarefs relevant to these specific meshes and their parents
                selectedMeshes.forEach(mesh => {
                    let curr = mesh;
                    while (curr && curr !== rootGroup && curr !== scene) {
                        for (let ctrl of animationControllers) {
                            if (ctrl.target === curr && ctrl.dref) {
                                activeDatarefs.add(ctrl.dref);
                            }
                        }
                        curr = curr.parent;
                    }
                });
            } else {
                // Normal mode: Show Union of all DataRefs used by currently visible objects
                loadedObjects.forEach(obj => {
                    if (obj.group.visible) {
                        obj.datarefs.forEach(d => activeDatarefs.add(d));
                    }
                });
            }

            // Separate active and inactive items for sorting
            const activeItems = [];
            const inactiveItems = [];

            guiControllers.forEach(item => {
                const isMatch = item.name.toLowerCase().includes(term);
                const isActive = activeDatarefs.has(item.name);
                const isVisible = isMatch && isActive;

                if (isVisible) {
                    item.controller.domElement.style.display = '';
                    activeItems.push(item);
                } else {
                    item.controller.domElement.style.display = 'none';
                    inactiveItems.push(item);
                }
            });

            // Sort active items: Least usage first, then alphabetical
            activeItems.sort((a, b) => {
                if (a.count !== b.count) return a.count - b.count;
                return a.name.localeCompare(b.name);
            });

            // Re-order DOM
            if (guiControllers.length > 0) {
                const container = guiControllers[0].controller.domElement.parentElement;
                if (container) {
                    // Append active ones in order
                    activeItems.forEach(item => container.appendChild(item.controller.domElement));
                    // Append inactive ones (keeps them in the DOM but hidden)
                    inactiveItems.forEach(item => container.appendChild(item.controller.domElement));
                }
            }
        }

        function showToast(msg) {
            const toast = document.createElement('div');
            toast.className = 'copy-toast';
            toast.textContent = msg;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 2000);
        }

        function onResize() {
            const vp = document.getElementById('viewport');
            camera.aspect = vp.clientWidth / vp.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(vp.clientWidth, vp.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            for (const ctrl of animationControllers) {
                const val = guiData[ctrl.dref];
                if (val === undefined) continue;
                if (ctrl.type === 'translate') ctrl.target.position.copy(interpolate(val, ctrl.keys));
                else if (ctrl.type === 'rotate') ctrl.target.quaternion.setFromAxisAngle(ctrl.axis, interpolate(val, ctrl.keys) * (Math.PI / 180));
                else if (ctrl.type === 'hide') {
                    if (isSpaceDown) ctrl.target.visible = true;
                    else {
                        if (ctrl.min <= ctrl.max) {
                            ctrl.target.visible = !(val >= ctrl.min && val <= ctrl.max);
                        } else {
                            // Reversed: hide if outside [max, min], i.e., show if inside (max, min)
                            ctrl.target.visible = (val > ctrl.max && val < ctrl.min);
                        }
                    }
                }
                else if (ctrl.type === 'show') {
                    if (isSpaceDown) ctrl.target.visible = true;
                    else {
                        if (ctrl.min <= ctrl.max) {
                            ctrl.target.visible = (val >= ctrl.min && val <= ctrl.max);
                        } else {
                            // Reversed: show if outside [max, min]
                            ctrl.target.visible = (val <= ctrl.max || val >= ctrl.min);
                        }
                    }
                }
            }
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>

</html>