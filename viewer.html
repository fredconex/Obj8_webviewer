<!-- START OF FILE ai_studio_code (71).html -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>X-Plane OBJ8 Inspector V14 - Dark Studio</title>
    <style>
        :root {
            --bg-color: #121212;
            --panel-bg: #1e1e1e;
            --border-color: #333;
            --text-main: #e0e0e0;
            --text-muted: #888;
            --accent: #4db8ff;
            --accent-hover: #6ac4ff;
            --item-hover: #2d2d2d;
            --item-selected: #3a4b5c;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: var(--text-main);
        }

        /* --- SCROLLBARS --- */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--panel-bg);
        }

        ::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* --- LAYOUT --- */
        #app-container {
            display: flex;
            width: 100vw;
            height: 100vh;
        }

        /* --- SIDEBAR (Left) --- */
        #sidebar {
            width: 320px;
            background: var(--panel-bg);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            z-index: 10;
            padding: 15px;
            box-sizing: border-box;
            transition: transform 0.3s;
        }

        /* --- MAIN VIEWPORT --- */
        #viewport {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
            background: #0f0f0f;
        }

        /* --- OVERLAY CONTROLS (Right - DataRefs) --- */
        #ui-right-container {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 320px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: none;
            z-index: 20;
        }

        #search-container {
            pointer-events: auto;
            background: var(--panel-bg);
            padding: 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            position: relative;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            flex-shrink: 0;
        }

        #gui-scroll-wrapper {
            pointer-events: auto;
            overflow-y: auto;
            overflow-x: hidden;
            border-radius: 4px;
            max-height: 100%;
        }

        /* --- FLOATING INSPECTOR (Bottom Right) --- */
        #selection-panel {
            position: absolute;
            bottom: 20px;
            right: 350px;
            /* Left of the right UI */
            width: 300px;
            background: rgba(30, 30, 30, 0.95);
            border: 1px solid var(--accent);
            border-radius: 6px;
            padding: 15px;
            display: none;
            flex-direction: column;
            gap: 10px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            z-index: 30;
        }

        #selection-panel.active {
            display: flex;
        }

        #selection-header {
            font-size: 0.85rem;
            text-transform: uppercase;
            color: var(--accent);
            font-weight: bold;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
        }

        .close-selection {
            cursor: pointer;
            color: #aaa;
        }

        .close-selection:hover {
            color: #fff;
        }

        .control-row {
            display: flex;
            flex-direction: column;
            margin-bottom: 8px;
        }

        .control-label {
            font-size: 0.75rem;
            color: #ccc;
            margin-bottom: 4px;
            display: flex;
            justify-content: space-between;
        }

        .control-val {
            color: var(--accent);
            font-family: monospace;
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--accent);
            cursor: pointer;
        }

        /* --- TYPOGRAPHY & ELEMENTS --- */
        h1 {
            margin: 0 0 15px 0;
            font-size: 1rem;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 2px solid var(--accent);
            padding-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h2 {
            margin: 15px 0 8px 0;
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            margin-bottom: 4px;
            color: #bbb;
        }

        .stat-val {
            font-family: monospace;
            color: var(--accent);
        }

        /* --- OBJECT LIST --- */
        #obj-list-wrapper {
            flex-grow: 1;
            /* Takes remaining height */
            min-height: 100px;
            display: flex;
            flex-direction: column;
            margin-bottom: 10px;
        }

        #obj-list-container {
            border: 1px solid var(--border-color);
            background: #161616;
            overflow-y: auto;
            border-radius: 4px;
            flex-grow: 1;
        }

        .obj-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            font-size: 0.8rem;
            border-bottom: 1px solid #252525;
            cursor: pointer;
            transition: background 0.1s;
        }

        .obj-item:hover {
            background: var(--item-hover);
            color: #fff;
        }

        .obj-item.selected-obj {
            background: var(--item-selected);
        }

        .obj-name {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .icon-btn {
            cursor: pointer;
            width: 20px;
            text-align: center;
            font-weight: bold;
            color: #666;
            user-select: none;
        }

        .icon-btn:hover {
            color: #fff;
        }

        .eye-btn.hidden {
            color: #444;
        }

        .eye-btn:not(.hidden) {
            color: var(--accent);
        }

        .solo-btn {
            font-size: 0.7rem;
            border: 1px solid #444;
            border-radius: 3px;
            width: 18px;
            height: 18px;
            line-height: 16px;
        }

        .solo-btn.active {
            background: #ffaa00;
            color: #000;
            border-color: #ffaa00;
        }

        /* --- CONTROLS --- */
        .btn {
            background: #2a2a2a;
            color: #eee;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #444;
            cursor: pointer;
            font-weight: 600;
            width: 100%;
            font-size: 0.8rem;
            margin-top: 5px;
            text-align: center;
            transition: 0.2s;
        }

        .btn:hover {
            background: #3a3a3a;
            border-color: var(--accent);
            color: #fff;
        }

        .btn-danger {
            background: #601818;
            border-color: #802020;
            width: auto;
            padding: 4px 8px;
            font-size: 0.7rem;
        }

        .btn-danger:hover {
            background: #902020;
        }

        .chk-label {
            font-size: 0.8rem;
            color: #ccc;
            display: flex;
            align-items: center;
            margin-top: 6px;
            cursor: pointer;
        }

        .chk-label input {
            margin-right: 8px;
            accent-color: var(--accent);
        }

        #view-mode-select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%234db8ff%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
            background-repeat: no-repeat;
            background-position: right 0.7rem top 50%;
            background-size: 0.65rem auto;
            text-align: left;
            padding-left: 10px;
        }

        /* --- SEARCH --- */
        #dref-search {
            width: 100%;
            box-sizing: border-box;
            background: #111;
            border: 1px solid #555;
            color: #fff;
            padding: 8px 30px 8px 10px;
            border-radius: 4px;
            font-size: 0.85rem;
        }

        #dref-search:focus {
            outline: none;
            border-color: var(--accent);
        }

        #search-clear {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: #666;
            cursor: pointer;
            font-weight: bold;
            font-size: 1rem;
        }

        #search-clear:hover {
            color: #fff;
        }

        /* --- UPLOAD --- */
        #upload-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(18, 18, 18, 0.98);
            z-index: 200;
            pointer-events: auto;
            transition: opacity 0.4s;
        }

        #upload-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .drop-box {
            border: 2px dashed #555;
            padding: 50px;
            border-radius: 12px;
            text-align: center;
            color: #888;
            transition: 0.2s;
            background: #222;
        }

        .drop-box:hover {
            border-color: var(--accent);
            color: #fff;
            background: #252525;
        }

        /* Lil GUI Customization */
        .lil-gui {
            width: 100% !important;
            pointer-events: auto;
            --background-color: var(--panel-bg);
            --text-color: #ddd;
            --widget-color: #333;
            --hover-color: #444;
            --name-width: 50%;
        }

        .lil-gui .title {
            display: none;
        }

        .lil-gui .controller {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            padding: 6px 12px !important;
            border-bottom: 1px solid #252525;
            height: auto !important;
        }

        .lil-gui .name {
            width: 100% !important;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding-bottom: 4px;
            order: 1;
            cursor: copy;
            user-select: none;
            font-size: 0.75rem;
            color: var(--accent);
        }

        .lil-gui .widget {
            width: 100% !important;
            height: 26px;
            order: 2;
        }

        /* Notification style for copy */
        .copy-toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--accent);
            color: #000;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: bold;
            z-index: 1000;
            pointer-events: none;
            animation: fadeout 2s forwards;
        }

        @keyframes fadeout {
            0% {
                opacity: 1;
            }

            80% {
                opacity: 1;
            }

            100% {
                opacity: 0;
            }
        }

        /* --- CONTEXT MENU --- */
        #context-menu {
            position: fixed;
            background: #252525;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 5px 0;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            min-width: 150px;
        }

        .context-menu-item {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.85rem;
            color: #ddd;
            transition: background 0.1s;
        }

        .context-menu-item:hover {
            background: var(--accent);
            color: #000;
        }

        .context-menu-item.disabled {
            color: #555;
            pointer-events: none;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.172.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.172.0/examples/jsm/",
                "lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
            }
        }
    </script>
</head>

<body>

    <div id="app-container">
        <!-- SIDEBAR -->
        <div id="sidebar" class="hidden-ui">
            <h1>OBJ8 Inspector <button class="btn btn-danger" id="close-btn" name="close-btn">Close</button></h1>

            <div class="stat-row"><span>Files:</span> <span id="f-count" class="stat-val">0</span></div>
            <div class="stat-row"><span>Vertices:</span> <span id="v-count" class="stat-val">0</span></div>
            <div class="stat-row"><span>Meshes:</span> <span id="m-count" class="stat-val">0</span></div>

            <h2>Objects</h2>
            <div id="obj-list-wrapper">
                <div id="obj-list-container">
                    <!-- Items injected by JS -->
                </div>
            </div>

            <h2>View</h2>
            <div class="stat-row">
                <label for="view-mode-select">Mode:</label>
                <select id="view-mode-select" name="view-mode-select" class="btn"
                    style="width: 150px; margin-top: 0; padding: 4px;">
                    <option value="material">Material</option>
                    <option value="solid">Solid</option>
                    <option value="albedo">Albedo (Unlit)</option>
                    <option value="lit_only">Lit Only (Emissive)</option>
                    <option value="normals">Normals</option>
                    <option value="wireframe">Wireframe</option>
                </select>
            </div>
            <button class="btn" id="recenter-btn" name="recenter-btn">Recenter Camera</button>
            <label class="chk-label"><input type="checkbox" id="skeleton-chk" name="skeleton-chk"> Show Pivot
                Skeleton</label>
            <!-- Shadows removed per request -->

            <h2>Material Defaults</h2>
            <div class="stat-row"><label for="mat-rough">Roughness</label><input type="range" id="mat-rough"
                    name="mat-rough" min="0" max="1" step="0.05">
            </div>
            <div class="stat-row"><label for="mat-metal">Metalness</label><input type="range" id="mat-metal"
                    name="mat-metal" min="0" max="1" step="0.05">
            </div>
            <div class="stat-row"><label for="cam-exposure">Exposure</label><input type="range" id="cam-exposure"
                    name="cam-exposure" min="0.1" max="2" step="0.1">
            </div>
        </div>

        <!-- MAIN 3D VIEWPORT -->
        <div id="viewport"></div>
    </div>

    <!-- CONTEXT MENU -->
    <div id="context-menu">
        <div class="context-menu-item" id="cm-hide">Hide Selected Mesh</div>
        <div class="context-menu-item" id="cm-unhide-all">Unhide All</div>
    </div>

    <!-- FLOATING CONTROLS (Right) -->
    <div id="ui-right-container" class="hidden-ui">
        <div id="search-container">
            <input type="text" id="dref-search" name="dref-search" placeholder="Filter DataRefs..." autocomplete="off"
                aria-label="Filter DataRefs">
            <span id="search-clear">âœ•</span>
        </div>
        <div id="gui-scroll-wrapper">
            <!-- Lil-GUI appends here -->
        </div>
    </div>

    <!-- SELECTION PANEL REMOVED -->

    <!-- UPLOAD SCREEN -->
    <div id="upload-overlay">
        <div class="drop-box" id="drop-target">
            <h2 style="color:#fff; margin-top:0;">X-Plane OBJ8 Viewer</h2>
            <p>Drag & Drop one or multiple .OBJ files</p>
            <label for="file-input" class="btn" style="width: auto; display: inline-block; margin-top:15px;">
                Browse Files
                <input type="file" id="file-input" name="file-input" accept=".obj,.png,.jpg,.jpeg,.bmp" multiple
                    style="display:none">
            </label>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import GUI from 'lil-gui';

        // --- GLOBALS ---
        let scene, camera, renderer, controls, gui;
        let rootGroup;
        let pmremGenerator;
        let raycaster, mouse;
        let lightGroup; // Container for rotatable lights
        let mouseDownPos = { x: 0, y: 0 };

        // Logic Data
        let animationControllers = [];
        let datarefRanges = new Map();
        let guiData = {};
        let guiControllers = [];
        let skeletonHelpers = [];
        let loadedObjects = [];
        let soloModeObject = null;

        // Resources
        let loadedTextures = new Map();
        let materialCache = new Map();
        let selectedMeshes = [];

        // Stats
        let totalVertices = 0;
        let filesLoadedCount = 0;

        // Settings (Defaults)
        const settings = {
            exposure: 1.0,
            rough: 0.5, metal: 0.2
        };

        // Lights
        let headlight, ambientLight, mainLight;
        let currentViewMode = 'material';

        function init() {
            loadSettings();

            const viewport = document.getElementById('viewport');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x121212); // Darker background

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(viewport.clientWidth, viewport.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.AgXToneMapping;
            renderer.toneMappingExposure = settings.exposure;
            viewport.appendChild(renderer.domElement);

            // Raycaster for Selection
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // PBR Environment
            pmremGenerator = new THREE.PMREMGenerator(renderer);
            scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
            scene.environmentIntensity = 0.5; // Balanced reflections

            // Camera
            camera = new THREE.PerspectiveCamera(45, viewport.clientWidth / viewport.clientHeight, 0.01, 2000);
            camera.position.set(3, 3, 5);
            scene.add(camera);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            rootGroup = new THREE.Group();
            scene.add(rootGroup);

            // Grid
            const grid = new THREE.GridHelper(30, 30, 0x333333, 0x0f0f0f);
            scene.add(grid);
            scene.add(new THREE.AxesHelper(1));

            // Improved Studio Lighting Setup
            ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            // Main Sun Light (Fixed)
            mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(10, 20, 10);
            scene.add(mainLight);

            // Camera Headlight (Soft Fill that follows camera)
            headlight = new THREE.DirectionalLight(0xffffff, 0.5);
            camera.add(headlight);
            // Position it slightly offset from camera center for better depth
            headlight.position.set(1, 1, 1);

            // GUI
            const guiContainer = document.getElementById('gui-scroll-wrapper');
            gui = new GUI({ container: guiContainer, width: '100%' });

            setupDOMControls();

            window.addEventListener('resize', onResize);
            window.addEventListener('keydown', e => {
                if (e.key.toLowerCase() === 'f' && document.activeElement.tagName !== 'INPUT') {
                    centerCamera();
                }
            });
            viewport.addEventListener('mousedown', (e) => {
                mouseDownPos.x = e.clientX;
                mouseDownPos.y = e.clientY;
            });
            viewport.addEventListener('click', onClick);

            // File Handling
            const drop = document.getElementById('drop-target');
            window.addEventListener('dragover', e => { e.preventDefault(); drop.style.borderColor = '#4db8ff'; });
            window.addEventListener('dragleave', e => { drop.style.borderColor = '#555'; });
            window.addEventListener('drop', handleDrop);
            document.getElementById('file-input').addEventListener('change', handleFile);

            // Button Logic
            document.getElementById('recenter-btn').addEventListener('click', centerCamera);
            document.getElementById('close-btn').addEventListener('click', resetViewer);
            document.getElementById('dref-search').addEventListener('input', filterDataRefs);
            document.getElementById('search-clear').addEventListener('click', () => {
                document.getElementById('dref-search').value = '';
                filterDataRefs({ target: { value: '' } });
            });
            document.getElementById('view-mode-select').addEventListener('change', (e) => {
                currentViewMode = e.target.value;
                refreshMaterials();
            });


            viewport.addEventListener('contextmenu', onContextMenu);
            window.addEventListener('click', hideContextMenu);
            document.getElementById('cm-hide').addEventListener('click', hideSelectedMesh);
            document.getElementById('cm-unhide-all').addEventListener('click', unhideAllMeshes);

            animate();
        }

        function loadSettings() {
            const s = localStorage.getItem('xp_obj_viewer_settings_v14');
            if (s) { try { Object.assign(settings, JSON.parse(s)); } catch (e) { } }
        }
        function saveSettings() { localStorage.setItem('xp_obj_viewer_settings_v14', JSON.stringify(settings)); }

        function setupDOMControls() {
            const setVal = (id, val) => document.getElementById(id).value = val;
            setVal('mat-rough', settings.rough);
            setVal('mat-metal', settings.metal);
            setVal('cam-exposure', settings.exposure);

            const bind = (id, fn) => {
                const el = document.getElementById(id);
                if (el) el.addEventListener('input', (e) => { fn(e); saveSettings(); });
            };

            bind('mat-rough', e => { settings.rough = parseFloat(e.target.value); refreshMaterials(); });
            bind('mat-metal', e => { settings.metal = parseFloat(e.target.value); refreshMaterials(); });
            bind('cam-exposure', e => { settings.exposure = parseFloat(e.target.value); renderer.toneMappingExposure = settings.exposure; });

            document.getElementById('skeleton-chk').addEventListener('change', e => skeletonHelpers.forEach(h => h.visible = e.target.checked));
        }

        function onClick(event) {
            if (event.button !== 0) return; // Left click only

            // Check if we moved significant distance (likely panning)
            const dx = event.clientX - mouseDownPos.x;
            const dy = event.clientY - mouseDownPos.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > 5) return;

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(rootGroup.children, true);

            if (intersects.length > 0) {
                const hit = intersects.find(i => {
                    if (i.object.type !== 'Mesh') return false;
                    let curr = i.object;
                    while (curr && curr !== scene) {
                        if (!curr.visible) return false;
                        curr = curr.parent;
                    }
                    return true;
                });

                if (hit) {
                    selectMesh(hit.object, event.shiftKey);
                } else {
                    if (!event.shiftKey) deselectMesh();
                }
            } else {
                if (!event.shiftKey) deselectMesh();
            }
        }

        function selectMesh(mesh, append = false) {
            if (!append) {
                if (selectedMeshes.length === 1 && selectedMeshes[0] === mesh) {
                    deselectMesh();
                    return;
                }
                deselectMesh();
                selectedMeshes = [mesh];
            } else {
                const idx = selectedMeshes.indexOf(mesh);
                if (idx > -1) {
                    restoreMeshMaterial(mesh);
                    selectedMeshes.splice(idx, 1);
                    updateDataRefVisibility();
                    return;
                }
                selectedMeshes.push(mesh);
            }

            highlightMesh(mesh);
            updateDataRefVisibility();
        }

        function highlightMesh(mesh) {
            if (mesh._oldMaterial) return;
            mesh._oldMaterial = mesh.material;
            mesh.material = mesh.material.clone();
            mesh.material.emissive.setHex(0x0077ff);
            mesh.material.emissiveIntensity = 2.0;
            mesh.material.emissiveMap = null;
        }

        function restoreMeshMaterial(mesh) {
            if (mesh._oldMaterial) {
                mesh.material.dispose();
                mesh.material = mesh._oldMaterial;
                mesh._oldMaterial = null;
            }
        }

        function deselectMesh() {
            selectedMeshes.forEach(m => restoreMeshMaterial(m));
            selectedMeshes = [];
            updateDataRefVisibility();
        }

        // --- CONTEXT MENU LOGIC ---
        function onContextMenu(event) {
            event.preventDefault();

            // Check if we moved significant distance (likely panning)
            const dx = event.clientX - mouseDownPos.x;
            const dy = event.clientY - mouseDownPos.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > 5) return; // Ignore if moved more than 5 pixels

            // Try to select mesh under cursor
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(rootGroup.children, true);
            const hit = intersects.find(i => {
                if (i.object.type !== 'Mesh') return false;
                let curr = i.object;
                while (curr && curr !== scene) {
                    if (!curr.visible) return false;
                    curr = curr.parent;
                }
                return true;
            });

            if (hit) {
                if (!selectedMeshes.includes(hit.object)) {
                    selectMesh(hit.object, event.shiftKey);
                }
            } else {
                // User said deselecting shouldn't happen on right click
                // So we do nothing here to keep current selection
            }

            const menu = document.getElementById('context-menu');
            const hideItem = document.getElementById('cm-hide');

            if (selectedMeshes.length > 0) {
                hideItem.classList.remove('disabled');
            } else {
                hideItem.classList.add('disabled');
            }

            menu.style.display = 'block';
            menu.style.left = `${event.clientX}px`;
            menu.style.top = `${event.clientY}px`;
        }

        function hideContextMenu() {
            document.getElementById('context-menu').style.display = 'none';
        }

        function hideSelectedMesh() {
            if (selectedMeshes.length > 0) {
                selectedMeshes.forEach(m => m.visible = false);
                deselectMesh();
                hideContextMenu();
            }
        }

        function unhideAllMeshes() {
            const showSkeleton = document.getElementById('skeleton-chk').checked;

            rootGroup.traverse(obj => {
                // If it's a mesh or a group, unhide it
                if (obj.isMesh || obj.isGroup) {
                    obj.visible = true;
                }

                // If it's a skeleton helper part, check the global skeleton visibility setting
                if (skeletonHelpers.includes(obj)) {
                    obj.visible = showSkeleton;
                }
            });
            // Update sidebar icons
            loadedObjects.forEach(obj => {
                obj.visible = true;
                obj.eye.classList.remove('hidden');
                obj.div.style.opacity = '1';
            });
            soloModeObject = null;
            hideContextMenu();
        }

        function resetViewer() {
            rootGroup.clear();
            skeletonHelpers = [];
            animationControllers = [];
            datarefRanges.clear();
            guiData = {};
            guiControllers = [];
            loadedObjects = [];
            soloModeObject = null;

            materialCache.clear();
            loadedTextures.clear();

            filesLoadedCount = 0;
            totalVertices = 0;

            document.getElementById('obj-list-container').innerHTML = '';
            document.getElementById('dref-search').value = '';
            deselectMesh();

            if (gui) {
                // Clear all controllers and folders from the GUI
                [...gui.folders].forEach(f => f.destroy());
                [...gui.controllers].forEach(c => c.destroy());
            }

            document.getElementById('upload-overlay').classList.remove('hidden');
            document.getElementById('sidebar').classList.add('hidden-ui');
            document.getElementById('ui-right-container').classList.add('hidden-ui');
            updateStats();
        }

        function handleDrop(e) {
            e.preventDefault();
            document.getElementById('drop-target').style.borderColor = '#555';
            if (e.dataTransfer.files.length) processFiles(e.dataTransfer.files);
        }
        function handleFile(e) { if (e.target.files.length) processFiles(e.target.files); }

        async function processFiles(files) {
            if (filesLoadedCount === 0) {
                document.getElementById('upload-overlay').classList.add('hidden');
                document.getElementById('sidebar').classList.remove('hidden-ui');
                document.getElementById('ui-right-container').classList.remove('hidden-ui');
            }

            const fileList = Array.from(files);
            const texLoader = new THREE.TextureLoader();

            // 1. Identify and load images first
            const imgFiles = fileList.filter(f => /\.(png|jpg|jpeg|bmp)$/i.test(f.name));
            const texPromises = imgFiles.map(f => {
                return new Promise((resolve) => {
                    const url = URL.createObjectURL(f);
                    texLoader.load(url, (tex) => {
                        const isNormalMap = f.name.toLowerCase().includes('_nrm');
                        tex.colorSpace = isNormalMap ? THREE.NoColorSpace : THREE.SRGBColorSpace;
                        tex.name = f.name.toLowerCase();
                        // X-Plane OBJ8 uses standard UVs where 0,0 is bottom-left
                        // Three.js flipY=true (default) means 0 is bottom
                        tex.flipY = true;
                        tex.wrapS = THREE.RepeatWrapping;
                        tex.wrapT = THREE.RepeatWrapping;
                        loadedTextures.set(f.name.toLowerCase(), tex);
                        URL.revokeObjectURL(url);
                        resolve();
                    }, undefined, () => {
                        URL.revokeObjectURL(url);
                        resolve();
                    });
                });
            });

            await Promise.all(texPromises);

            // 2. Process OBJs
            for (const file of fileList) {
                if (file.name.toLowerCase().endsWith('.obj')) {
                    const text = await file.text();
                    parseOBJ8(text, file.name);
                }
            }

            // 3. Finalize UI and View
            buildGUI();
            updateStats();
            centerCamera();
        }

        // --- PARSER ---
        function parseOBJ8(text, fileName) {
            filesLoadedCount++;
            const fileGroup = new THREE.Group();
            fileGroup.name = fileName;
            rootGroup.add(fileGroup);

            // Register for List
            registerObjectUI(fileName, fileGroup);

            const vertices = [];
            const indices = [];
            const lines = text.split(/\r?\n/);

            let currentTexture = "default";
            let litTexture = null;
            let normalTexture = null;
            // Pre-scan texture(s)
            for (let i = 0; i < Math.min(lines.length, 100); i++) {
                const l = lines[i].split('#')[0].trim();
                const parts = l.split(/\s+/);
                if (parts[0] === 'TEXTURE') { currentTexture = parts[1]; }
                if (parts[0] === 'TEXTURE_LIT') { litTexture = parts[1]; }
                if (parts[0] === 'TEXTURE_NORMAL') { normalTexture = parts[1]; }
            }

            const groupStack = [{ object: fileGroup }];
            const currentGroup = () => groupStack[groupStack.length - 1].object;
            let currentAnimKey = null;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].split('#')[0].trim();
                if (!line) continue;
                const tokens = line.split(/\s+/).filter(t => t.length > 0);
                const cmd = tokens[0];

                try {
                    if (cmd === 'VT') {
                        vertices.push({
                            x: parseFloat(tokens[1]), y: parseFloat(tokens[2]), z: parseFloat(tokens[3]),
                            nx: parseFloat(tokens[4]), ny: parseFloat(tokens[5]), nz: parseFloat(tokens[6]),
                            u: parseFloat(tokens[7]), v: parseFloat(tokens[8])
                        });
                        totalVertices++;
                    }
                    else if (cmd.startsWith('IDX')) {
                        for (let j = 1; j < tokens.length; j++) indices.push(parseInt(tokens[j]));
                    }
                    else if (cmd === 'TRIS') {
                        createMesh(tokens, vertices, indices, currentGroup, currentTexture, litTexture, normalTexture);
                    }
                    else if (cmd === 'ANIM_begin') {
                        const g = new THREE.Group();
                        currentGroup().add(g);
                        groupStack.push({ object: g });
                    }
                    else if (cmd === 'ANIM_end') {
                        if (groupStack.length > 1) groupStack.pop();
                    }
                    else if (cmd === 'ANIM_trans') {
                        // ALWAYS APPLY STATIC TRANSFORMS
                        let isStatic = false;
                        if (tokens.length <= 4) isStatic = true;
                        else if (tokens.length >= 7 && !isNaN(parseFloat(tokens[6]))) {
                            const x1 = parseFloat(tokens[1]), x2 = parseFloat(tokens[4]);
                            if (Math.abs(x1 - x2) < 0.0001) isStatic = true;
                        }

                        if (isStatic) {
                            const wrapper = createWrapperGroup(groupStack);
                            let x = 0, y = 0, z = 0;
                            if (tokens.length >= 4) { x = parseFloat(tokens[1]); y = parseFloat(tokens[2]); z = parseFloat(tokens[3]); }
                            wrapper.position.set(x, y, z);
                            addSkeletonHelper(wrapper, 0xffff00, 0.05);
                        } else {
                            const wrapper = createWrapperGroup(groupStack);
                            const dref = tokens[tokens.length - 1];
                            const v1 = parseFloat(tokens[1]), v2 = parseFloat(tokens[2]);
                            const p1 = new THREE.Vector3(parseFloat(tokens[3]), parseFloat(tokens[4]), parseFloat(tokens[5]));
                            const p2 = new THREE.Vector3(parseFloat(tokens[6]), parseFloat(tokens[7]), parseFloat(tokens[8]));
                            registerDataRef(dref, v1, v2);
                            animationControllers.push({ type: 'translate', target: wrapper, dref: dref, keys: [{ val: v1, pos: p1 }, { val: v2, pos: p2 }] });
                            addSkeletonHelper(wrapper, 0x00ff00, 0.1);
                        }
                    }
                    else if (cmd === 'ANIM_rotate') {
                        const lastToken = tokens[tokens.length - 1];
                        const isStatic = !isNaN(parseFloat(lastToken));
                        const axis = new THREE.Vector3(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3])).normalize();

                        if (isStatic) {
                            const wrapper = createWrapperGroup(groupStack);
                            const angle = parseFloat(tokens[4]);
                            wrapper.quaternion.setFromAxisAngle(axis, angle * (Math.PI / 180));
                            addSkeletonHelper(wrapper, 0xffaa00, 0.05);
                        } else {
                            const wrapper = createWrapperGroup(groupStack);
                            const dref = tokens[8];
                            const v1 = parseFloat(tokens[6]), v2 = parseFloat(tokens[7]);
                            registerDataRef(dref, v1, v2);
                            animationControllers.push({ type: 'rotate', target: wrapper, dref: dref, axis: axis, keys: [{ val: v1, angle: parseFloat(tokens[4]) }, { val: v2, angle: parseFloat(tokens[5]) }] });
                            addSkeletonHelper(wrapper, 0xff0000, 0.1);
                        }
                    }
                    else if (cmd === 'ANIM_trans_begin') {
                        const dref = tokens[1];
                        currentAnimKey = { type: 'translate', dref: dref, keys: [], group: createWrapperGroup(groupStack) };
                    }
                    else if (cmd === 'ANIM_rotate_begin') {
                        const axis = new THREE.Vector3(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3])).normalize();
                        const dref = tokens[4];
                        currentAnimKey = { type: 'rotate', dref: dref, axis: axis, keys: [], group: createWrapperGroup(groupStack) };
                        addSkeletonHelper(currentAnimKey.group, 0xff00ff, 0.1);
                    }
                    else if (cmd.endsWith('_key')) {
                        if (currentAnimKey) {
                            const val = parseFloat(tokens[1]);
                            registerDataRef(currentAnimKey.dref, val);
                            if (currentAnimKey.type === 'translate') currentAnimKey.keys.push({ val: val, pos: new THREE.Vector3(parseFloat(tokens[2]), parseFloat(tokens[3]), parseFloat(tokens[4])) });
                            else currentAnimKey.keys.push({ val: val, angle: parseFloat(tokens[2]) });
                        }
                    }
                    else if (cmd.endsWith('_end')) {
                        if (currentAnimKey) {
                            animationControllers.push({ type: currentAnimKey.type, target: currentAnimKey.group, dref: currentAnimKey.dref, axis: currentAnimKey.axis, keys: currentAnimKey.keys });
                            currentAnimKey = null;
                        }
                    }
                    else if (cmd === 'ANIM_hide' || cmd === 'ANIM_show') {
                        if (tokens.length >= 4) {
                            const v1 = parseFloat(tokens[1]), v2 = parseFloat(tokens[2]), dref = tokens[3];
                            registerDataRef(dref, v1, v2);
                            const wrapper = createWrapperGroup(groupStack);
                            animationControllers.push({ type: cmd === 'ANIM_hide' ? 'hide' : 'show', target: wrapper, dref: dref, min: v1, max: v2 });
                        }
                    }
                } catch (e) {
                    console.warn(`[OBJ8 Parser] Error in ${fileName} at line ${i + 1}: "${line}"`, e);
                }
            }
        }

        // --- MESH GENERATION ---
        function createMesh(tokens, vertices, indices, currentGroup, texName, litName, normName) {
            const offset = parseInt(tokens[1]);
            const count = parseInt(tokens[2]);
            const geo = new THREE.BufferGeometry();
            const pos = [], norm = [], uv = [];

            for (let k = 0; k < count; k++) {
                let vIdx = offset + k;
                if (indices.length > 0) vIdx = (vIdx < indices.length) ? indices[vIdx] : 0;
                if (vIdx < vertices.length) {
                    const v = vertices[vIdx];
                    pos.push(v.x, v.y, v.z);
                    norm.push(v.nx, v.ny, v.nz);
                    uv.push(v.u, v.v);
                }
            }
            if (pos.length > 0) {
                geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                geo.setAttribute('normal', new THREE.Float32BufferAttribute(norm, 3));
                geo.setAttribute('uv', new THREE.Float32BufferAttribute(uv, 2));

                const mat = getMaterial(texName, litName, normName);
                const mesh = new THREE.Mesh(geo, mat);
                mesh._textureName = texName;
                mesh._litName = litName;
                mesh._normalName = normName;
                // Shadows removed
                currentGroup().add(mesh);
            }
        }

        function registerObjectUI(name, group) {
            const container = document.getElementById('obj-list-container');
            const div = document.createElement('div');
            div.className = 'obj-item';

            const nameSpan = document.createElement('span');
            nameSpan.className = 'obj-name';
            nameSpan.title = name;
            nameSpan.textContent = name;

            const eye = document.createElement('span');
            eye.className = 'icon-btn eye-btn';
            eye.textContent = 'ðŸ‘';

            const solo = document.createElement('span');
            solo.className = 'icon-btn solo-btn';
            solo.textContent = 'S';
            solo.title = 'Solo Object';

            const objRecord = { name, group, visible: true, div, eye, solo, datarefs: new Set() };
            loadedObjects.push(objRecord);

            // Toggle Visibility
            eye.onclick = (e) => {
                e.stopPropagation();
                if (soloModeObject) return; // Disable toggle in solo mode
                objRecord.visible = !objRecord.visible;
                group.visible = objRecord.visible;
                eye.classList.toggle('hidden', !objRecord.visible);
                updateDataRefVisibility();
            };

            // Solo Mode
            solo.onclick = (e) => {
                e.stopPropagation();

                // Toggle Solo
                if (soloModeObject === objRecord) {
                    // Turn OFF Solo
                    soloModeObject = null;
                    solo.classList.remove('active');
                    // Restore previous states
                    loadedObjects.forEach(o => {
                        o.group.visible = o.visible;
                        o.div.style.opacity = '1';
                    });
                } else {
                    // Turn ON Solo (or switch solo target)
                    if (soloModeObject) soloModeObject.solo.classList.remove('active');
                    soloModeObject = objRecord;
                    solo.classList.add('active');

                    loadedObjects.forEach(o => {
                        if (o === soloModeObject) {
                            o.group.visible = true;
                            o.div.style.opacity = '1';
                        } else {
                            o.group.visible = false;
                            o.div.style.opacity = '0.5';
                        }
                    });
                    updateDataRefVisibility();
                }
            };

            // Hover Highlight
            let boxHelper = null;
            div.onmouseenter = () => {
                div.classList.add('selected-obj');
                boxHelper = new THREE.BoxHelper(group, 0xffff00);
                scene.add(boxHelper);
            };
            div.onmouseleave = () => {
                div.classList.remove('selected-obj');
                if (boxHelper) scene.remove(boxHelper);
                boxHelper = null;
            };

            div.appendChild(nameSpan);
            div.appendChild(solo);
            div.appendChild(eye);
            container.appendChild(div);
        }

        // --- DATAREFS ---
        function registerDataRef(name, ...values) {
            if (!name) return;
            // Record in the most recently added object (the one currently being parsed)
            if (loadedObjects.length > 0) {
                loadedObjects[loadedObjects.length - 1].datarefs.add(name);
            }

            let entry = datarefRanges.get(name);
            if (!entry) { entry = { min: Infinity, max: -Infinity }; datarefRanges.set(name, entry); }
            values.forEach(v => {
                if (v < entry.min) entry.min = v;
                if (v > entry.max) entry.max = v;
            });
        }

        function buildGUI() {
            // Instead of destroying everything, we rebuild the list properly
            // Clear existing UI references but keep guiData for state persistence
            [...gui.folders].forEach(f => f.destroy());
            [...gui.controllers].forEach(c => c.destroy());
            guiControllers = [];

            const sortedKeys = Array.from(datarefRanges.keys()).sort();
            sortedKeys.forEach(name => {
                const range = datarefRanges.get(name);
                let min = range.min, max = range.max;
                let span = max - min;
                if (span === 0) span = 1;
                const margin = span * 0.05; // 10% total (5% each side)
                min -= margin; max += margin;

                // Set default to 0 if valid, otherwise min
                if (guiData[name] === undefined) {
                    guiData[name] = (0 >= min && 0 <= max) ? 0 : range.min;
                }

                const ctrl = gui.add(guiData, name, min, max).name(name).listen();

                // Add click-to-copy and accessibility attributes
                setTimeout(() => {
                    const label = ctrl.domElement.querySelector('.name');
                    if (label) {
                        label.addEventListener('dblclick', (e) => {
                            e.stopPropagation();
                            navigator.clipboard.writeText(name);
                            showToast(`Copied: ${name}`);
                        });
                    }
                    const inputs = ctrl.domElement.querySelectorAll('input, select');
                    inputs.forEach((input, idx) => {
                        if (!input.name) input.name = name + (idx > 0 ? '-' + idx : '');
                        if (!input.id) input.id = 'gui-' + name.replace(/\W/g, '-') + (idx > 0 ? '-' + idx : '');
                    });
                }, 10);

                guiControllers.push({ name: name, controller: ctrl });
            });

            // Re-apply filter immediately after rebuild
            const searchVal = document.getElementById('dref-search').value;
            filterDataRefs({ target: { value: searchVal } });
        }

        function interpolate(val, keys) {
            if (keys.length === 0) return null;
            const first = keys[0];
            const last = keys[keys.length - 1];
            if (keys.length === 1) return first.pos ? first.pos.clone() : first.angle;

            let k1, k2;
            const isIncreasing = first.val < last.val;

            if (isIncreasing) {
                if (val <= first.val) {
                    k1 = keys[0]; k2 = keys[1];
                } else if (val >= last.val) {
                    k1 = keys[keys.length - 2]; k2 = keys[keys.length - 1];
                } else {
                    for (let i = 0; i < keys.length - 1; i++) {
                        if (val >= keys[i].val && val <= keys[i + 1].val) {
                            k1 = keys[i]; k2 = keys[i + 1]; break;
                        }
                    }
                }
            } else {
                if (val >= first.val) {
                    k1 = keys[0]; k2 = keys[1];
                } else if (val <= last.val) {
                    k1 = keys[keys.length - 2]; k2 = keys[keys.length - 1];
                } else {
                    for (let i = 0; i < keys.length - 1; i++) {
                        if (val <= keys[i].val && val >= keys[i + 1].val) {
                            k1 = keys[i]; k2 = keys[i + 1]; break;
                        }
                    }
                }
            }

            if (!k1 || !k2) return first.pos ? first.pos.clone() : first.angle;

            const t = (val - k1.val) / (k2.val - k1.val);
            if (k1.pos) return new THREE.Vector3().copy(k1.pos).lerp(k2.pos, t);
            return k1.angle + (k2.angle - k1.angle) * t;
        }

        function createWrapperGroup(stack) {
            const currentLevel = stack[stack.length - 1];
            const parent = currentLevel.object;
            const wrapper = new THREE.Group();
            parent.add(wrapper);
            currentLevel.object = wrapper;
            return wrapper;
        }

        function getMaterial(textureName, litName, normalName) {
            const baseName = textureName ? textureName.split(/[/\\]/).pop() : "default";
            const litBase = litName ? litName.split(/[/\\]/).pop() : null;
            const normBase = normalName ? normalName.split(/[/\\]/).pop() : null;
            const cacheKey = `${baseName}|${litBase}|${normBase}|${currentViewMode}|${settings.rough}|${settings.metal}`;

            if (!materialCache.has(cacheKey)) {
                let mat;
                if (currentViewMode === 'albedo') {
                    mat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
                } else if (currentViewMode === 'lit_only') {
                    mat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
                } else if (currentViewMode === 'normals') {
                    mat = new THREE.MeshNormalMaterial({ side: THREE.DoubleSide });
                } else {
                    mat = new THREE.MeshStandardMaterial({
                        name: baseName,
                        color: 0xbbbbbb, side: THREE.DoubleSide,
                        roughness: settings.rough, metalness: settings.metal
                    });
                    if (currentViewMode === 'wireframe') mat.wireframe = true;
                }

                const findTex = (name) => {
                    if (!name || name === "default") return null;
                    const low = name.toLowerCase();
                    const candidates = [low, low + ".png", low + ".jpg", low + ".jpeg", low + ".bmp",
                        low.replace(/\.[^/.]+$/, "") + ".png", low.replace(/\.[^/.]+$/, "") + ".jpg"];
                    for (const c of candidates) { if (loadedTextures.has(c)) return loadedTextures.get(c); }
                    return null;
                };

                // Apply Textures based on mode
                if (currentViewMode === 'material') {
                    const tex = findTex(baseName);
                    if (tex) { mat.map = tex; mat.color.set(0xffffff); }

                    const ltex = findTex(litBase);
                    if (ltex) { mat.emissiveMap = ltex; mat.emissive.set(0xffffff); mat.emissiveIntensity = 1.0; }

                    let ntex = findTex(normBase);
                    if (!ntex && baseName) {
                        // Auto-detect _NRM if no normal texture is specified
                        const baseWithoutExt = baseName.replace(/\.[^/.]+$/, "");
                        ntex = findTex(baseWithoutExt + "_NRM") || findTex(baseWithoutExt + "_nrm");
                    }
                    if (ntex) { mat.normalMap = ntex; mat.normalScale.set(1, 1); }
                } else if (currentViewMode === 'albedo') {
                    const tex = findTex(baseName);
                    if (tex) mat.map = tex;
                } else if (currentViewMode === 'lit_only') {
                    const ltex = findTex(litBase);
                    if (ltex) mat.map = ltex; else mat.color.set(0x000000);
                } else if (currentViewMode === 'solid' || currentViewMode === 'wireframe') {
                    mat.color.set(0x888888);
                }

                materialCache.set(cacheKey, mat);
            }
            return materialCache.get(cacheKey);
        }

        function refreshMaterials() {
            rootGroup.traverse(obj => {
                if (obj.isMesh) {
                    const t = obj._textureName, l = obj._litName, n = obj._normalName;
                    if (selectedMeshes.includes(obj)) {
                        obj._oldMaterial = getMaterial(t, l, n);
                        const highlight = obj._oldMaterial.clone();
                        highlight.emissive.setHex(0x0077ff);
                        highlight.emissiveIntensity = 2.0;
                        highlight.emissiveMap = null;
                        if (obj.material && obj.material.dispose) obj.material.dispose();
                        obj.material = highlight;
                    } else {
                        obj.material = getMaterial(t, l, n);
                        obj._oldMaterial = null;
                    }
                }
            });
        }

        function addSkeletonHelper(group, color, size) {
            const axes = new THREE.AxesHelper(size);
            const geom = new THREE.SphereGeometry(size / 5, 4, 4);
            const mat = new THREE.MeshBasicMaterial({ color: color, wireframe: true });
            const sphere = new THREE.Mesh(geom, mat);
            group.add(axes);
            group.add(sphere);
            const visible = document.getElementById('skeleton-chk').checked;
            axes.visible = visible; sphere.visible = visible;
            skeletonHelpers.push(axes, sphere);
        }

        function updateStats() {
            document.getElementById('f-count').innerText = filesLoadedCount;
            document.getElementById('v-count').innerText = totalVertices;
            document.getElementById('m-count').innerText = renderer.info.render.triangles;
        }

        function centerCamera() {
            if (rootGroup.children.length === 0) return;

            const box = new THREE.Box3();
            let hasBounds = false;

            if (selectedMeshes.length > 0) {
                // Center on selection
                selectedMeshes.forEach(m => {
                    m.geometry.computeBoundingBox();
                    const b = new THREE.Box3().copy(m.geometry.boundingBox).applyMatrix4(m.matrixWorld);
                    box.union(b);
                });
                hasBounds = true;
            } else {
                // Center on all visible meshes
                rootGroup.traverse(obj => {
                    if (obj.isMesh) {
                        // Check if object and all ancestors (up to rootGroup) are visible
                        let curr = obj;
                        let visible = true;
                        while (curr && curr !== scene) {
                            if (!curr.visible) {
                                visible = false;
                                break;
                            }
                            curr = curr.parent;
                        }

                        if (visible) {
                            obj.geometry.computeBoundingBox();
                            const meshBox = new THREE.Box3().copy(obj.geometry.boundingBox).applyMatrix4(obj.matrixWorld);
                            box.union(meshBox);
                            hasBounds = true;
                        }
                    }
                });
            }

            if (!hasBounds || box.isEmpty()) return;

            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());

            // Calculate distance needed to fit the box
            const maxDim = Math.max(size.x, size.y, size.z);
            if (isNaN(maxDim) || maxDim <= 0) return;

            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
            cameraZ = Math.max(cameraZ * 1.5, 0.5); // Add padding and ensure minimum distance

            // Move camera along its current view direction
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);

            const newPos = center.clone().add(direction.multiplyScalar(-cameraZ));
            camera.position.copy(newPos);

            controls.target.copy(center);
            controls.update();
        }

        function filterDataRefs(e) {
            updateDataRefVisibility();
        }

        function updateDataRefVisibility() {
            const term = document.getElementById('dref-search').value.toLowerCase();

            // Determine active datarefs based on visibility AND potential selection
            const activeDatarefs = new Set();

            if (selectedMeshes.length > 0) {
                // Only show datarefs relevant to these specific meshes and their parents
                selectedMeshes.forEach(mesh => {
                    let curr = mesh;
                    while (curr && curr !== rootGroup && curr !== scene) {
                        for (let ctrl of animationControllers) {
                            if (ctrl.target === curr && ctrl.dref) {
                                activeDatarefs.add(ctrl.dref);
                            }
                        }
                        curr = curr.parent;
                    }
                });
            } else {
                // Normal mode: Show Union of all DataRefs used by currently visible objects
                loadedObjects.forEach(obj => {
                    if (obj.group.visible) {
                        obj.datarefs.forEach(d => activeDatarefs.add(d));
                    }
                });
            }

            guiControllers.forEach(item => {
                if (item.controller && item.controller.domElement) {
                    const isVisible = item.name.toLowerCase().includes(term) && activeDatarefs.has(item.name);
                    item.controller.domElement.style.display = isVisible ? '' : 'none';
                }
            });
        }

        function showToast(msg) {
            const toast = document.createElement('div');
            toast.className = 'copy-toast';
            toast.textContent = msg;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 2000);
        }

        function onResize() {
            const vp = document.getElementById('viewport');
            camera.aspect = vp.clientWidth / vp.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(vp.clientWidth, vp.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            for (const ctrl of animationControllers) {
                const val = guiData[ctrl.dref];
                if (val === undefined) continue;
                if (ctrl.type === 'translate') ctrl.target.position.copy(interpolate(val, ctrl.keys));
                else if (ctrl.type === 'rotate') ctrl.target.quaternion.setFromAxisAngle(ctrl.axis, interpolate(val, ctrl.keys) * (Math.PI / 180));
                else if (ctrl.type === 'hide') ctrl.target.visible = !(val >= ctrl.min && val <= ctrl.max);
                else if (ctrl.type === 'show') ctrl.target.visible = (val >= ctrl.min && val <= ctrl.max);
            }
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>

</html>