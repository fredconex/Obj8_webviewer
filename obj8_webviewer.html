<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>X-Plane OBJ8 WebViewer</title>
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <style>
        :root {
            --bg-color: #121212;
            --panel-bg: #1e1e1e;
            --border-color: #333;
            --text-main: #e0e0e0;
            --text-muted: #888;
            --accent: #4db8ff;
            --accent-hover: #6ac4ff;
            --item-hover: #2d2d2d;
            --item-selected: #3a4b5c;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: var(--text-main);
        }

        /* --- SCROLLBARS --- */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--panel-bg);
        }

        ::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* --- LAYOUT --- */
        #app-container {
            display: flex;
            width: 100vw;
            height: 100vh;
        }

        /* --- SIDEBAR (Left) --- */
        #sidebar {
            position: absolute;
            top: 15px;
            left: 15px;
            width: 320px;
            height: calc(100% - 30px);
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 20;
            pointer-events: none;
            transition: transform 0.3s;
        }

        .glass-panel {
            background: rgba(30, 30, 30, 0.85);
            backdrop-filter: blur(8px);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            pointer-events: auto;
        }

        #sidebar-header {
            padding: 12px 15px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            flex-shrink: 0;
        }

        #sidebar-content {
            flex-grow: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
            padding: 10px;
            padding-top: 5px;
            overflow: hidden;
        }

        /* --- MAIN VIEWPORT --- */
        #viewport {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
            background: #0f0f0f;
            width: 100vw;
            /* Force full width now that sidebar is overlay */
        }

        /* --- OVERLAY CONTROLS (Right - DataRefs) --- */
        #ui-right-container {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 320px;
            max-height: calc(100vh - 60px);
            /* Match sidebar height logic */
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: none;
            z-index: 20;
        }

        #search-container {
            pointer-events: auto;
            background: rgba(30, 30, 30, 0.85);
            padding: 8px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            flex-shrink: 0;
            backdrop-filter: blur(8px);
        }

        #gui-scroll-wrapper {
            pointer-events: auto;
            overflow-y: auto;
            overflow-x: hidden;
            border-radius: 8px;
            max-height: 100%;
            background: rgba(30, 30, 30, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(8px);
        }

        /* --- FLOATING INSPECTOR (Bottom Right) --- */
        #selection-panel {
            position: absolute;
            bottom: 20px;
            right: 350px;
            /* Left of the right UI */
            width: 300px;
            background: rgba(30, 30, 30, 0.95);
            border: 1px solid var(--accent);
            border-radius: 6px;
            padding: 15px;
            display: none;
            flex-direction: column;
            gap: 10px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            z-index: 30;
        }

        #selection-panel.active {
            display: flex;
        }

        #selection-header {
            font-size: 0.85rem;
            text-transform: uppercase;
            color: var(--accent);
            font-weight: bold;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
        }

        .close-selection {
            cursor: pointer;
            color: #aaa;
        }

        .close-selection:hover {
            color: #fff;
        }

        .control-row {
            display: flex;
            flex-direction: column;
            margin-bottom: 8px;
        }

        .control-label {
            font-size: 0.75rem;
            color: #ccc;
            margin-bottom: 4px;
            display: flex;
            justify-content: space-between;
        }

        .control-val {
            color: var(--accent);
            font-family: monospace;
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--accent);
            cursor: pointer;
            background: transparent;
        }

        input[type=range]::-webkit-slider-runnable-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        input[type=range]::-moz-range-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        /* --- TYPOGRAPHY & ELEMENTS --- */
        h1 {
            margin: 0;
            font-size: 1rem;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding-bottom: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h2 {
            margin: 10px 0 8px 5px;
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            margin-bottom: 4px;
            color: #bbb;
        }

        .stat-val {
            font-family: monospace;
            color: var(--accent);
        }

        /* --- OBJECT LIST --- */
        #obj-list-wrapper {
            flex-grow: 1;
            /* Takes remaining height */
            min-height: 100px;
            display: flex;
            flex-direction: column;
            margin-bottom: 0;
            overflow: hidden;
        }

        #obj-list-container {
            border: none;
            background: transparent;
            overflow-y: auto;
            border-radius: 4px;
            flex-grow: 1;
        }

        .obj-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            font-size: 0.8rem;
            border-bottom: 1px solid #252525;
            cursor: pointer;
            transition: background 0.1s;
            color: #666;
            /* Darker default text */
            user-select: none;
        }

        .obj-item:hover {
            background: var(--item-hover);
            color: #fff;
        }

        /* Hover state from JS (synced with box helper) */
        .obj-item.hover-active {
            background: var(--item-hover);
            color: #fff;
        }

        /* Selected state from clicking mesh or item */
        .obj-item.active-entry {
            background: rgba(255, 255, 255, 0.08);
            /* Much more subtle than var(--item-selected) */
            color: #fff;
            font-weight: 500;
            border-left: 2px solid var(--accent);
        }

        .obj-name {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .icon-btn {
            cursor: pointer;
            width: 20px;
            text-align: center;
            font-weight: bold;
            color: #666;
            user-select: none;
        }

        .icon-btn:hover {
            color: #fff;
        }

        .eye-btn.hidden {
            color: #666;
        }

        .eye-btn:not(.hidden) {
            color: #fff;
        }

        .solo-btn {
            font-size: 0.7rem;
            border: 1px solid #444;
            border-radius: 3px;
            width: 18px;
            height: 18px;
            line-height: 16px;
        }

        .solo-btn.active {
            background: #ffaa00;
            color: #000;
            border-color: #ffaa00;
        }

        /* --- CONTROLS --- */
        .btn {
            background: #2a2a2a;
            color: #eee;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #444;
            cursor: pointer;
            font-weight: 600;
            width: 100%;
            font-size: 0.8rem;
            margin-top: 5px;
            text-align: center;
            transition: 0.2s;
        }

        .btn:hover {
            background: #3a3a3a;
            border-color: var(--accent);
            color: #fff;
        }

        .btn-danger {
            background: #601818;
            border-color: #802020;
            width: auto;
            padding: 4px 8px;
            font-size: 0.7rem;
        }

        .btn-danger:hover {
            background: #902020;
        }

        /* Modern styled toggle switches */
        .chk-label {
            font-size: 0.8rem;
            color: #ccc;
            display: flex;
            align-items: center;
            margin-top: 6px;
            cursor: pointer;
            position: relative;
            user-select: none;
        }

        .chk-label input[type="checkbox"] {
            opacity: 0;
            width: 0;
            height: 0;
            position: absolute;
            margin: 0;
        }

        .chk-label .toggle-switch {
            width: 40px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            position: relative;
            margin-right: 8px;
            transition: background 0.3s;
            flex-shrink: 0;
        }

        .chk-label .toggle-switch::before {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #888;
            top: 2px;
            left: 2px;
            transition: transform 0.3s, background 0.3s;
        }

        .chk-label input[type="checkbox"]:checked+.toggle-switch {
            background: var(--accent);
        }

        .chk-label input[type="checkbox"]:checked+.toggle-switch::before {
            transform: translateX(20px);
            background: #fff;
        }

        .chk-label input[type="checkbox"]:focus+.toggle-switch {
            box-shadow: 0 0 0 2px rgba(77, 184, 255, 0.3);
        }

        #view-mode-select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%234db8ff%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
            background-repeat: no-repeat;
            background-position: right 0.7rem top 50%;
            background-size: 0.65rem auto;
            text-align: left;
            padding-left: 10px;
        }

        /* --- SEARCH --- */
        #dref-search {
            width: 100%;
            box-sizing: border-box;
            background: #111;
            border: 1px solid #555;
            color: #fff;
            padding: 8px 30px 8px 10px;
            border-radius: 4px;
            font-size: 0.85rem;
        }

        #dref-search:focus {
            outline: none;
            border-color: var(--accent);
        }

        #search-clear {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: #666;
            cursor: pointer;
            font-weight: bold;
            font-size: 1rem;
        }

        #search-clear:hover {
            color: #fff;
        }

        /* --- UPLOAD --- */
        #upload-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(18, 18, 18, 0.98);
            z-index: 200;
            pointer-events: auto;
            transition: opacity 0.4s;
        }

        #upload-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .drop-box {
            border: 2px dashed #555;
            padding: 50px;
            border-radius: 12px;
            text-align: center;
            color: #888;
            transition: 0.2s;
            background: #222;
        }

        .drop-box:hover {
            border-color: var(--accent);
            color: #fff;
            background: #252525;
        }

        /* Lil GUI Customization */
        .lil-gui {
            width: 100% !important;
            pointer-events: auto;
            --background-color: transparent;
            --text-color: #ddd;
            --widget-color: rgba(0, 0, 0, 0.3);
            --hover-color: rgba(255, 255, 255, 0.05);
            --name-width: 50%;
        }

        .lil-gui .title {
            display: none;
        }

        .lil-gui .controller {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            padding: 6px 12px !important;
            border-bottom: 1px solid #252525;
            height: auto !important;
        }

        .lil-gui .name {
            width: 100% !important;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding-bottom: 4px;
            order: 1;
            user-select: none;
            font-size: 0.75rem;
            color: var(--accent);
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
        }

        .copy-btn-inline {
            font-size: 14px !important;
            cursor: pointer;
            color: rgba(255, 255, 255, 0.3);
            transition: color 0.2s;
            flex-shrink: 0;
        }

        .copy-btn-inline:hover {
            color: var(--accent);
        }

        .lil-gui .widget {
            width: 100% !important;
            height: 26px;
            order: 2;
        }

        /* Notification style for copy */
        .copy-toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--accent);
            color: #000;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: bold;
            z-index: 1000;
            pointer-events: none;
            animation: fadeout 2s forwards;
        }

        @keyframes fadeout {
            0% {
                opacity: 1;
            }

            80% {
                opacity: 1;
            }

            100% {
                opacity: 0;
            }
        }

        /* --- UPDATE NOTIFICATIONS --- */
        #notification-container {
            display: flex;
            flex-direction: column;
            pointer-events: none;
            width: 100%;
            flex-shrink: 0;
        }

        .update-toast {
            background: rgba(25, 25, 25, 0.6);
            color: var(--text-muted);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 500;
            animation: slideInLeft 0.3s ease-out, fadeOutDelayed 5s forwards;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 1px solid rgba(77, 184, 255, 0.1);
            margin-top: 5px;
            width: 100%;
            box-sizing: border-box;
        }

        .update-toast span.material-symbols-outlined {
            font-size: 14px;
            color: var(--accent);
            opacity: 0.7;
        }

        @keyframes slideInLeft {
            from {
                transform: translateX(-100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes fadeOutDelayed {
            0% {
                opacity: 1;
            }

            80% {
                opacity: 1;
            }

            100% {
                opacity: 0;
            }
        }

        /* --- COLLAPSIBLE STATS --- */
        .collapsible-container {
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: #1a1a1a;
            margin-bottom: 10px;
            overflow: hidden;
        }

        .collapsible-header {
            background: #252525;
            padding: 8px 12px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
            font-weight: bold;
            color: var(--accent);
            user-select: none;
        }

        .collapsible-header:hover {
            background: #2d2d2d;
        }

        .collapsible-content {
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .collapsible-content.collapsed {
            display: none;
        }

        #stats-toggle-icon {
            transition: transform 0.2s;
            font-size: 0.7rem;
        }

        .collapsed #stats-toggle-icon {
            transform: rotate(-90deg);
        }

        /* --- VIEWPORT TOOLBAR --- */
        #viewport-toolbar {
            position: absolute;
            top: 15px;
            left: 350px;
            display: flex;
            gap: 6px;
            z-index: 100;
            background: rgba(30, 30, 30, 0.85);
            /* Slightly transparent */
            padding: 6px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(8px);
            align-items: center;
        }

        .icon-btn-tool {
            background: transparent;
            border: 1px solid transparent;
            color: #aaa;
            cursor: pointer;
            min-width: 34px;
            height: 34px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            transition: 0.2s;
            padding: 0 8px;
            font-size: 0.8rem;
            font-weight: 600;
            white-space: nowrap;
        }

        .icon-btn-tool:hover {
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
        }

        .icon-btn-tool.active {
            color: var(--accent);
            border: 1px solid rgba(77, 184, 255, 0.3);
            background: rgba(77, 184, 255, 0.1);
        }

        .icon-btn-tool span {
            font-size: 20px;
        }

        .toolbar-separator {
            width: 1px;
            height: 20px;
            background: #444;
            margin: 0 4px;
        }

        .toolbar-select {
            background: #222;
            color: #eee;
            border: 1px solid #444;
            padding: 0 10px;
            border-radius: 6px;
            height: 34px;
            cursor: pointer;
            outline: none;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .toolbar-select:hover {
            border-color: #666;
        }

        /* --- STATS OVERLAY --- */
        #stats-overlay {
            position: absolute;
            top: 70px;
            /* Below toolbar */
            left: 350px;
            background: rgba(0, 0, 0, 0.0);
            /* Transparent as requested */
            padding: 0;
            pointer-events: none;
            z-index: 90;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .stat-line {
            color: #777;
            font-size: 0.8rem;
            font-family: 'Consolas', monospace;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .stat-line .val {
            color: inherit;
            margin-left: 8px;
        }

        /* --- POPUP MENUS --- */
        .popup-menu {
            position: absolute;
            top: 100%;
            /* Below parent */
            left: 0;
            margin-top: 10px;
            background: rgba(25, 25, 25, 0.95);
            border: 1px solid #444;
            padding: 15px;
            border-radius: 8px;
            width: 240px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            z-index: 101;
            transform-origin: top left;
            transition: opacity 0.2s, transform 0.2s;
        }

        .popup-menu.hidden {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.95);
        }

        .popup-section h3 {
            margin: 0 0 8px 0;
            font-size: 0.7rem;
            text-transform: uppercase;
            color: #666;
            border-bottom: 1px solid #333;
            padding-bottom: 4px;
        }

        .popup-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 5px;
            font-size: 0.8rem;
            color: #ccc;
        }

        .popup-row span.material-symbols-outlined {
            font-size: 18px;
            color: #888;
        }

        .color-preview-box {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 1px solid #444;
            cursor: pointer;
            flex-shrink: 0;
            transition: transform 0.1s;
        }

        .color-preview-box:hover {
            transform: scale(1.1);
            border-color: var(--accent);
        }

        .hidden-color-input {
            opacity: 0;
            width: 0;
            height: 0;
            position: absolute;
            pointer-events: none;
        }

        /* --- LOADING BAR --- */
        #loading-bar-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            background: rgba(30, 30, 30, 0.95);
            border: 1px solid var(--accent);
            border-radius: 8px;
            padding: 20px;
            z-index: 300;
            display: none;
            flex-direction: column;
            gap: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
        }

        #loading-bar-container.active {
            display: flex;
        }

        #loading-bar-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--accent);
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #loading-bar-track {
            width: 100%;
            height: 8px;
            background: #1a1a1a;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        #loading-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--accent-hover));
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        #loading-bar-text {
            font-size: 0.75rem;
            color: #aaa;
            text-align: center;
            font-family: 'Consolas', monospace;
        }

        /* --- VIEWPORT BLUR DURING LOADING --- */
        #viewport.loading {
            filter: blur(8px);
            transition: filter 0.3s ease;
        }

        #branding {
            position: absolute;
            bottom: 10px;
            right: 15px;
            font-size: 0.7rem;
            color: #555;
            pointer-events: none;
            z-index: 100;
            font-family: 'Segoe UI', sans-serif;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
            user-select: none;
        }

        /* --- SHORTCUTS OVERLAY --- */
        #shortcuts-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.7);
            z-index: 500;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }

        #shortcuts-overlay.active {
            display: flex;
        }

        #shortcuts-panel {
            background: #1e1e1e;
            border: 1px solid #444;
            border-radius: 12px;
            padding: 30px;
            width: 600px;
            max-width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
            position: relative;
        }

        #shortcuts-panel h2 {
            margin-top: 0;
            color: #fff;
            font-size: 1.2rem;
            border-bottom: 1px solid #333;
            padding-bottom: 15px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .shortcut-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px 40px;
        }

        .shortcut-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            color: #ccc;
        }

        .key-badge {
            background: #333;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 2px 8px;
            font-family: 'Consolas', monospace;
            font-size: 0.8rem;
            color: #fff;
            box-shadow: 0 2px 0 #111;
            min-width: 20px;
            text-align: center;
            display: inline-block;
        }

        .key-badge.large {
            padding: 2px 12px;
        }

        .key-group {
            display: flex;
            gap: 4px;
        }

        #close-shortcuts {
            position: absolute;
            top: 20px;
            right: 20px;
            cursor: pointer;
            color: #888;
            transition: color 0.2s;
        }

        #close-shortcuts:hover {
            color: #fff;
        }

        .hidden-ui {
            display: none !important;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.172.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.172.0/examples/jsm/",
                "lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.min.js",
                "three/addons/loaders/DDSLoader.js": "https://unpkg.com/three@0.172.0/examples/jsm/loaders/DDSLoader.js"
            }
        }
    </script>
</head>

<body>

    <div id="app-container">
        <!-- SIDEBAR -->
        <div id="sidebar" class="hidden-ui">
            <div id="sidebar-header" class="glass-panel">
                <h1>OBJ8
                    <div style="display:flex; gap:6px;">
                        <button id="import-btn" class="btn"
                            style="width: auto; padding: 4px 8px; margin:0; font-size: 0.7rem;">
                            Import
                        </button>
                        <button class="btn btn-danger" id="clear-btn" name="clear-btn"
                            style="padding: 4px 8px; margin:0; font-size: 0.7rem; width: auto;">Clear</button>
                        <label class="chk-label"
                            style="margin: 0; font-size: 0.7rem; display: flex; align-items: center; color: var(--text-muted); cursor: pointer; margin-left: 8px;"
                            title="Automatically reload files when they change on disk">
                            <input type="checkbox" id="live-toggle">
                            <span class="toggle-switch"></span>
                            LIVE
                        </label>
                    </div>
                </h1>
            </div>

            <div id="sidebar-content" class="glass-panel">
                <h2>Objects</h2>
                <div id="obj-list-wrapper">
                    <div id="obj-list-container">
                        <!-- Items injected by JS -->
                    </div>
                </div>
                <div id="notification-container"></div>
            </div>
        </div>

        <!-- MAIN 3D VIEWPORT -->
        <div id="viewport">
            <!-- TOOLBAR -->
            <div id="viewport-toolbar" class="hidden-ui">
                <div class="toolbar-group">
                    <select id="view-mode-select" class="toolbar-select" title="View Mode">
                        <option value="material" selected>Material</option>
                        <option value="solid">Solid</option>
                        <option value="albedo">Albedo</option>
                        <option value="roughness">Roughness</option>
                        <option value="metallic">Metallic</option>
                        <option value="lit_only">Lit Only</option>
                        <option value="normals">Normals</option>
                        <option value="wireframe">Wireframe</option>
                        <option value="manipulators">Manipulators</option>
                    </select>
                </div>

                <div class="toolbar-separator"></div>

                <button id="recenter-btn" class="icon-btn-tool" title="Recenter Camera"><span
                        class="material-symbols-outlined">center_focus_strong</span></button>
                <button id="toggle-grid-btn" class="icon-btn-tool active" title="Toggle Grid"><span
                        class="material-symbols-outlined">grid_4x4</span></button>
                <button id="toggle-skeleton-btn" class="icon-btn-tool" title="Toggle Pivot Skeleton"><span
                        class="material-symbols-outlined">open_with</span></button>

                <div class="toolbar-separator"></div>

                <div style="position: relative;">
                    <button id="settings-btn" class="icon-btn-tool" title="Settings"><span
                            class="material-symbols-outlined">settings</span></button>
                    <!-- POPUP -->
                    <div id="settings-popup" class="hidden popup-menu">
                        <div class="popup-section">
                            <h3>Material Defaults</h3>
                            <div class="popup-row">
                                <span class="material-symbols-outlined" title="Roughness">texture</span>
                                <input type="range" id="mat-rough" min="0" max="1" step="0.05" title="Roughness">
                            </div>
                            <div class="popup-row">
                                <span class="material-symbols-outlined" title="Metalness">diamond</span>
                                <input type="range" id="mat-metal" min="0" max="1" step="0.05" title="Metalness">
                            </div>
                            <div class="popup-row">
                                <span class="material-symbols-outlined" title="LIT Intensity">lightbulb</span>
                                <input type="range" id="mat-lit" min="0" max="5" step="0.1" title="LIT Intensity">
                            </div>
                        </div>
                        <div class="popup-section">
                            <h3>Environment</h3>
                            <div class="popup-row">
                                <span class="material-symbols-outlined" title="HDR Environment">landscape</span>
                                <select id="env-hdr-select" class="toolbar-select"
                                    style="flex-grow: 1; height: 26px; font-size: 0.75rem; padding: 0 5px;">
                                    <option value="studio">Studio (Neutral)</option>
                                    <option value="venice">Venice Sunset</option>
                                    <option value="overpass">Pedestrian Overpass</option>
                                    <option value="custom">Load Custom HDR...</option>
                                </select>
                                <input type="file" id="custom-hdr-input" accept=".hdr" style="display:none">
                            </div>
                            <div class="popup-row">
                                <span class="material-symbols-outlined" title="Exposure">exposure</span>
                                <input type="range" id="cam-exposure" min="0.1" max="2" step="0.1" title="Exposure">
                            </div>
                            <div class="popup-row">
                                <span class="material-symbols-outlined" title="Env Intensity">light_mode</span>
                                <input type="range" id="env-intensity" min="0" max="2" step="0.1" title="Env Intensity">
                            </div>
                            <div class="popup-row">
                                <span class="material-symbols-outlined" title="Env Rotation">360</span>
                                <input type="range" id="env-rotation" min="0" max="360" step="1" title="Env Rotation">
                            </div>
                            <div class="popup-row">
                                <label class="chk-label">
                                    <input type="checkbox" id="env-bg-chk">
                                    <span class="toggle-switch"></span>
                                    Show Background
                                </label>
                            </div>
                            <div class="popup-row">
                                <label class="chk-label">
                                    <input type="checkbox" id="show-disabled-chk">
                                    <span class="toggle-switch"></span>
                                    Show Disabled Meshes
                                </label>
                            </div>
                            <div class="popup-row">
                                <label class="chk-label">
                                    <input type="checkbox" id="vr-hotspots-chk">
                                    <span class="toggle-switch"></span>
                                    Show VR Hotspots
                                </label>
                            </div>
                        </div>
                        <button id="restore-defaults-btn" class="btn btn-danger"
                            style="margin-top: 10px; width: 100%;">Restore Defaults</button>
                    </div>
                </div>

                <div style="position: relative;">
                    <button id="screenshot-tool-btn" class="icon-btn-tool" title="Screenshot"><span
                            class="material-symbols-outlined">photo_camera</span></button>
                    <!-- SCREENSHOT POPUP -->
                    <div id="screenshot-popup" class="hidden popup-menu">
                        <div class="popup-section">
                            <h3>Screenshot Settings</h3>
                            <div class="popup-row">
                                <span class="material-symbols-outlined" title="Background">wallpaper</span>
                                <select id="ss-bg-mode" class="toolbar-select"
                                    style="flex-grow: 1; height: 26px; font-size: 0.75rem; padding: 0 5px;">
                                    <option value="solid">Solid Color</option>
                                    <option value="gradient">Gradient</option>
                                    <option value="transparent">Transparent</option>
                                </select>
                                <div id="ss-color-container" style="display: flex; gap: 4px;">
                                    <div id="ss-color-preview-1" class="color-preview-box" title="Main Color"></div>
                                    <input type="color" id="ss-color-input-1" class="hidden-color-input">
                                    <div id="ss-color-preview-2" class="color-preview-box" title="Secondary Color">
                                    </div>
                                    <input type="color" id="ss-color-input-2" class="hidden-color-input">
                                </div>
                            </div>
                            <div style="display: flex; gap: 6px; margin-top: 5px;">
                                <button id="ss-capture-1x" class="btn" style="margin-top: 0; flex: 1;">Capture</button>
                                <button id="ss-capture-2x" class="btn"
                                    style="margin-top: 0; width: 40px; flex-shrink: 0;">2x</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div style="position: relative;">
                    <button id="shortcuts-btn" class="icon-btn-tool" title="Keyboard Shortcuts"><span
                            class="material-symbols-outlined">keyboard</span></button>
                </div>
            </div>

            <!-- STATS -->
            <div id="stats-overlay" class="hidden-ui">
                <div class="stat-line">Verts: <span id="v-count" class="val">0 / 0</span></div>
                <div class="stat-line">Tris: <span id="m-count" class="val">0 / 0</span></div>
                <div class="stat-line">Objects: <span id="o-count" class="val">0 / 0</span></div>
                <div class="stat-line">DataRefs: <span id="d-count" class="val">0</span></div>
                <div class="stat-line">Anims: <span id="a-count" class="val">0</span></div>
            </div>
            <!-- VIEWPORT ACTIONS -->
            <div style="position: absolute; bottom: 20px; left: 350px; z-index: 100; display: flex; gap: 8px;">
                <button id="hide-sel-btn" class="icon-btn-tool"
                    style="width: auto; background: rgba(0,0,0,0.5); border: 1px solid #444;" title="Hide Selected (H)">
                    Hide
                </button>
                <button id="isolate-sel-btn" class="icon-btn-tool"
                    style="width: auto; background: rgba(0,0,0,0.5); border: 1px solid #444;"
                    title="Isolate Selected (Shift+H)">
                    Isolate
                </button>
                <button id="unhide-all-btn" class="icon-btn-tool"
                    style="width: auto; background: rgba(0,0,0,0.5); border: 1px solid #444;"
                    title="Unhide All (Alt+H)">
                    Unhide All
                </button>
            </div>
            <div id="branding">WebViewer by Dreamfoil Creations</div>
        </div>
    </div>

    <!-- ACF SELECTION MODAL -->
    <div id="acf-selection-overlay" class="hidden-ui"
        style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.8); z-index: 600; display: flex; align-items: center; justify-content: center;">
        <div
            style="background: #1e1e1e; padding: 20px; border-radius: 8px; border: 1px solid #444; width: 400px; max-width: 90%;">
            <h3 style="margin-top: 0; color: #fff;">Select Aircraft File</h3>
            <div id="acf-list"
                style="display: flex; flex-direction: column; gap: 8px; max-height: 300px; overflow-y: auto; margin: 15px 0;">
                <!-- Buttons injected here -->
            </div>
            <button class="btn btn-danger"
                onclick="document.getElementById('acf-selection-overlay').classList.add('hidden-ui')">Cancel</button>
        </div>
    </div>

    <!-- SHORTCUTS OVERLAY -->
    <div id="shortcuts-overlay">
        <div id="shortcuts-panel">
            <span id="close-shortcuts" class="material-symbols-outlined">close</span>
            <h2><span class="material-symbols-outlined">keyboard</span> Keyboard Shortcuts</h2>
            <div class="shortcut-grid">
                <!-- Navigation -->
                <div class="shortcut-item">
                    <span>Move Forward</span>
                    <span class="key-badge">W</span>
                </div>
                <div class="shortcut-item">
                    <span>Move Backward</span>
                    <span class="key-badge">S</span>
                </div>
                <div class="shortcut-item">
                    <span>Move Left</span>
                    <span class="key-badge">A</span>
                </div>
                <div class="shortcut-item">
                    <span>Move Right</span>
                    <span class="key-badge">D</span>
                </div>
                <div class="shortcut-item">
                    <span>Move Up</span>
                    <span class="key-badge">E</span>
                </div>
                <div class="shortcut-item">
                    <span>Move Down</span>
                    <span class="key-badge">Q</span>
                </div>
                <div class="shortcut-item">
                    <span>Move Faster</span>
                    <span class="key-badge large">Shift</span>
                </div>

                <!-- Tools -->
                <div class="shortcut-item">
                    <span>Recenter Camera</span>
                    <span class="key-badge">F</span>
                </div>
                <div class="shortcut-item">
                    <span>Hide Selected</span>
                    <span class="key-badge">H</span>
                </div>
                <div class="shortcut-item">
                    <span>Isolate Selected</span>
                    <div class="key-group">
                        <span class="key-badge">Shift</span>
                        <span class="key-badge">H</span>
                    </div>
                </div>
                <div class="shortcut-item">
                    <span>Unhide All</span>
                    <div class="key-group">
                        <span class="key-badge">Alt</span>
                        <span class="key-badge">H</span>
                    </div>
                </div>
                <div class="shortcut-item">
                    <span>Show Hidden by Animation</span>
                    <span class="key-badge large">Space</span>
                </div>
            </div>
        </div>
    </div>

    <!-- FLOATING CONTROLS (Right) -->
    <div id="ui-right-container" class="hidden-ui">
        <div id="search-container">
            <input type="text" id="dref-search" name="dref-search" placeholder="Filter DataRefs..." autocomplete="off"
                aria-label="Filter DataRefs">
            <span id="search-clear">âœ•</span>
        </div>
        <div id="gui-scroll-wrapper">
            <!-- Lil-GUI appends here -->
        </div>
    </div>

    <!-- SELECTION PANEL -->
    <div id="selection-panel">
        <div id="selection-header">
            <span>Manipulator</span>
            <span class="material-symbols-outlined close-selection" id="close-selection-btn">close</span>
        </div>
        <div class="control-row">
            <div class="control-label">Type</div>
            <div class="control-val" id="sel-manip-type">--</div>
        </div>
        <div class="control-row" id="sel-manip-dref-row">
            <div class="control-label">
                <span id="sel-manip-label-text">DataRef</span>
                <span class="material-symbols-outlined icon-btn" id="sel-manip-copy-btn" style="font-size: 14px;"
                    title="Copy DataRef">content_copy</span>
            </div>
            <div class="control-val" id="sel-manip-dref" style="word-break: break-all; font-size: 0.75rem;">--</div>
        </div>
        <div class="control-row" id="sel-manip-tooltip-row">
            <div class="control-label">Tooltip</div>
            <div class="control-val" id="sel-manip-tooltip" style="font-size: 0.75rem; color: #aaa;">--</div>
        </div>
    </div>

    <!-- UPLOAD SCREEN -->

    <div id="upload-overlay">

        <div class="drop-box" id="drop-target">

            <h2 style="color:#fff; margin-top:0;">X-Plane OBJ8 Viewer</h2>

            <p>Drag & Drop one or multiple .OBJ files</p>



            <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">

                <label class="btn" style="width: auto; padding: 8px 20px; cursor: pointer; margin: 0;">

                    <span>Browse Files</span>

                    <input type="file" id="file-input" accept=".obj,.png,.jpg,.jpeg,.bmp,.hdr,.dds" multiple
                        style="display:none">

                </label>

                <button id="upload-acf-btn" class="btn" style="width: auto; padding: 8px 20px; margin: 0;">

                    Open ACF Folder

                </button>

            </div>

            <button id="upload-cancel-btn" class="btn btn-danger hidden-ui"
                style="margin-top: 20px; width: auto; padding: 4px 12px;">Cancel</button>

        </div>

    </div>

    <!-- LOADING BAR -->
    <div id="loading-bar-container">
        <div id="loading-bar-title">Loading Assets</div>
        <div id="loading-bar-track">
            <div id="loading-bar-fill"></div>
        </div>
        <div id="loading-bar-text">0 / 0</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { DDSLoader } from 'three/addons/loaders/DDSLoader.js';
        import GUI from 'lil-gui';

        // --- GLOBALS ---
        let scene, camera, renderer, controls, gui;
        let rootGroup, worldGrid, worldAxes;
        let pmremGenerator;
        let raycaster, mouse;
        let lightGroup; // Container for rotatable lights
        let mouseDownPos = { x: 0, y: 0 };

        // Logic Data
        let animationControllers = [];
        let datarefRanges = new Map();
        let guiData = {};
        let guiControllers = [];
        let skeletonHelpers = [];
        let loadedObjects = [];
        let soloObjects = new Set(); // Multi-select Set
        let isShiftDown = false; // Global Shift Tracking
        let isSpaceDown = false; // Global Space Tracking
        let keyState = { w: false, a: false, s: false, d: false, q: false, e: false };
        const moveSpeed = 0.01;
        let fileHandleMap = new Map(); // Filename -> {handle, lastModified}
        let lastUsedHandle = null; // Track last used folder/file for picker
        let lastClickedObjIndex = -1; // Track multi-selection range in list

        // Resources
        let loadedTextures = new Map();
        let materialCache = new Map();
        let selectedMeshes = [];
        let acfCgOffset = new THREE.Vector3(0, 0, 0); // Default CG Offset
        let vrHotspotsGroup = null; // Global reference for VR group

        // Stats
        let filesLoadedCount = 0;

        // Settings (Defaults)
        const defaultSettings = {
            exposure: 1.0,
            rough: 1.0, metal: 0.0, lit: 1.0,
            envIntensity: 0.8,
            rotation: 0,
            showBackground: false,
            showGrid: true,
            showDisabled: false,
            showVRHotspots: false,
            hdr: 'studio',
            live: false,
            ssBgMode: 'transparent',
            ssMultiplier: 1,
            ssBgColor1: '#121212',
            ssBgColor2: '#050505'
        };

        const settings = { ...defaultSettings };

        // Lights
        let headlight, ambientLight, mainLight;
        let currentViewMode = 'material';

        function init() {
            loadSettings();

            const viewport = document.getElementById('viewport');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x121212); // Darker background

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
            renderer.setSize(viewport.clientWidth, viewport.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.AgXToneMapping;
            renderer.toneMappingExposure = settings.exposure;
            viewport.appendChild(renderer.domElement);

            // Raycaster for Selection
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // PBR Environment
            pmremGenerator = new THREE.PMREMGenerator(renderer);
            scene.environmentIntensity = settings.envIntensity;
            const rotRad = (settings.rotation || 0) * (Math.PI / 180);
            scene.backgroundRotation.y = rotRad;
            scene.environmentRotation.y = rotRad;

            // Apply selected HDR (async)
            applyHDR();

            // Camera
            camera = new THREE.PerspectiveCamera(45, viewport.clientWidth / viewport.clientHeight, 0.01, 2000);
            camera.position.set(3, 3, 5);
            scene.add(camera);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = false;

            rootGroup = new THREE.Group();
            scene.add(rootGroup);

            // Grid
            worldGrid = new THREE.GridHelper(30, 30, 0x333333, 0x0f0f0f);
            scene.add(worldGrid);
            worldAxes = new THREE.AxesHelper(1);
            scene.add(worldAxes);

            // Improved Studio Lighting Setup
            ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            // Key Light (Main Sun)
            mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
            mainLight.position.set(10, 20, 10);
            scene.add(mainLight);

            // Fill Light
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.6);
            fillLight.position.set(-10, 10, 10);
            scene.add(fillLight);

            // Rim Light (Separation from background)
            const rimLight = new THREE.DirectionalLight(0xffffff, 0.8);
            rimLight.position.set(0, 5, -10);
            scene.add(rimLight);

            // Camera Headlight (Soft Fill that follows camera)
            headlight = new THREE.DirectionalLight(0xffffff, 0.3);
            camera.add(headlight);
            headlight.position.set(1, 1, 1);

            // GUI
            const guiContainer = document.getElementById('gui-scroll-wrapper');
            gui = new GUI({ container: guiContainer, width: '100%' });

            setupDOMControls();

            window.addEventListener('resize', onResize);
            window.addEventListener('keydown', e => {
                if (e.key === 'Shift') isShiftDown = true;

                // Camera Movement Keys
                const k = e.key.toLowerCase();
                if (document.activeElement.tagName !== 'INPUT') {
                    if (['w', 'a', 's', 'd', 'q', 'e'].includes(k)) {
                        keyState[k] = true;
                    }
                }

                if (e.code === 'Space' && document.activeElement.tagName !== 'INPUT') {
                    isSpaceDown = true;
                    e.preventDefault();
                }
                if (e.key.toLowerCase() === 'f' && document.activeElement.tagName !== 'INPUT') {
                    centerCamera();
                }
                // Handle hide/unhide shortcuts
                if (e.key.toLowerCase() === 'h' && document.activeElement.tagName !== 'INPUT') {
                    if (e.altKey) {
                        unhideAllMeshes();
                    } else if (e.shiftKey) {
                        isolateSelectedMesh();
                    } else {
                        hideSelectedMesh();
                    }
                    e.preventDefault();
                }
            });
            window.addEventListener('keyup', e => {
                if (e.key === 'Shift') isShiftDown = false;

                const k = e.key.toLowerCase();
                if (['w', 'a', 's', 'd', 'q', 'e'].includes(k)) {
                    keyState[k] = false;
                }

                if (e.code === 'Space') isSpaceDown = false;
            });
            window.addEventListener('blur', () => {
                isShiftDown = false;
                isSpaceDown = false;
                Object.keys(keyState).forEach(k => keyState[k] = false);
            });
            viewport.addEventListener('mousedown', (e) => {
                mouseDownPos.x = e.clientX;
                mouseDownPos.y = e.clientY;
            });
            viewport.addEventListener('mouseup', onClick);
            viewport.addEventListener('contextmenu', e => e.preventDefault());

            viewport.addEventListener('click', (e) => {
                // We use mouseup for selection logic to handle right-click, 
                // but we still want to prevent default click behavior if needed.
            });

            // File Handling
            const drop = document.getElementById('drop-target');
            window.addEventListener('dragover', e => { e.preventDefault(); drop.style.borderColor = '#4db8ff'; });
            window.addEventListener('dragleave', e => { drop.style.borderColor = '#555'; });
            window.addEventListener('drop', handleDrop);

            // Sidebar Import Button (Show Overlay)
            const sidebarImportBtn = document.getElementById('import-btn');
            sidebarImportBtn.addEventListener('click', () => {
                const overlay = document.getElementById('upload-overlay');
                overlay.classList.remove('hidden');

                // Show cancel button only if we already have files loaded
                const cancelBtn = document.getElementById('upload-cancel-btn');
                if (filesLoadedCount > 0) {
                    cancelBtn.classList.remove('hidden-ui');
                } else {
                    cancelBtn.classList.add('hidden-ui');
                }
            });

            // Upload Overlay Buttons
            document.getElementById('file-input').addEventListener('change', (e) => {
                handleFile(e);
                document.getElementById('upload-overlay').classList.add('hidden');
            });

            document.getElementById('upload-acf-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                openACFFolder();
                // Overlay hiding is handled inside loadACF/processFiles success
            });

            document.getElementById('upload-cancel-btn').addEventListener('click', () => {
                document.getElementById('upload-overlay').classList.add('hidden');
            });

            // Live Reload Interval
            setInterval(checkLiveReload, 1000);

            // Button Logic
            document.getElementById('recenter-btn').addEventListener('click', (e) => { e.stopPropagation(); centerCamera(); });
            document.getElementById('hide-sel-btn').addEventListener('click', (e) => { e.stopPropagation(); hideSelectedMesh(); });
            document.getElementById('isolate-sel-btn').addEventListener('click', (e) => { e.stopPropagation(); isolateSelectedMesh(); });
            document.getElementById('unhide-all-btn').addEventListener('click', (e) => { e.stopPropagation(); unhideAllMeshes(); });
            document.getElementById('clear-btn').addEventListener('click', resetViewer);
            document.getElementById('dref-search').addEventListener('input', filterDataRefs);
            document.getElementById('search-clear').addEventListener('click', () => {
                if (selectedMeshes.length > 0) {
                    deselectMesh();
                }
                document.getElementById('dref-search').value = '';
                filterDataRefs({ target: { value: '' } });
            });
            document.getElementById('view-mode-select').addEventListener('change', (e) => {
                currentViewMode = e.target.value;
                refreshMaterials();
                updateDisabledVisibility();
                updateVRHotspotsVisibility();
            });

            document.getElementById('stats-overlay').classList.remove('hidden-ui'); // Show stats
            document.getElementById('viewport-toolbar').classList.remove('hidden-ui'); // Show toolbar

            animate();
        }



        // Removed toggleStats as we use always-on overlay
        // function toggleStats() ...

        function loadSettings() {
            const s = localStorage.getItem('xp_obj_viewer_settings');
            if (s) { try { Object.assign(settings, JSON.parse(s)); } catch (e) { } }
        }
        function saveSettings() { localStorage.setItem('xp_obj_viewer_settings', JSON.stringify(settings)); }

        function setupDOMControls() {
            const setVal = (id, val) => {
                const el = document.getElementById(id);
                if (el) el.value = val;
            };
            setVal('mat-rough', settings.rough);
            setVal('mat-metal', settings.metal);
            setVal('mat-lit', settings.lit);
            setVal('cam-exposure', settings.exposure);
            setVal('env-intensity', settings.envIntensity);
            setVal('env-rotation', settings.rotation);
            setVal('env-hdr-select', settings.hdr || 'studio');

            const bind = (id, fn) => {
                const el = document.getElementById(id);
                if (el) el.addEventListener('input', (e) => { fn(e); saveSettings(); });
            };

            bind('mat-rough', e => { settings.rough = parseFloat(e.target.value); updateMaterialProperties(); });
            bind('mat-metal', e => { settings.metal = parseFloat(e.target.value); updateMaterialProperties(); });
            bind('mat-lit', e => { settings.lit = parseFloat(e.target.value); updateMaterialProperties(); });

            bind('cam-exposure', e => { settings.exposure = parseFloat(e.target.value); renderer.toneMappingExposure = settings.exposure; });
            bind('env-intensity', e => {
                settings.envIntensity = parseFloat(e.target.value);
                scene.environmentIntensity = settings.envIntensity;
                updateMaterialProperties();
            });
            bind('env-rotation', e => {
                settings.rotation = parseFloat(e.target.value);
                const rad = settings.rotation * (Math.PI / 180);
                scene.backgroundRotation.y = rad;
                scene.environmentRotation.y = rad;
            });
            bind('env-hdr-select', e => {
                if (e.target.value === 'custom') {
                    document.getElementById('custom-hdr-input').click();
                } else {
                    settings.hdr = e.target.value;
                    applyHDR();
                }
            });

            document.getElementById('custom-hdr-input').addEventListener('change', async (e) => {
                if (e.target.files.length > 0) {
                    const file = e.target.files[0];
                    const url = URL.createObjectURL(file);
                    try {
                        await loadHDRI(url);
                        settings.hdr = 'studio'; // Don't persist blob URLs
                        saveSettings();
                    } catch (err) {
                        console.error("Custom HDR failed:", err);
                    }
                    URL.revokeObjectURL(url);
                }
            });

            document.getElementById('env-bg-chk').checked = settings.showBackground;
            document.getElementById('env-bg-chk').addEventListener('change', e => {
                settings.showBackground = e.target.checked;
                updateBackground();
                saveSettings();
            });

            document.getElementById('show-disabled-chk').checked = settings.showDisabled;
            document.getElementById('show-disabled-chk').addEventListener('change', e => {
                settings.showDisabled = e.target.checked;
                updateDisabledVisibility();
                saveSettings();
            });

            document.getElementById('vr-hotspots-chk').checked = settings.showVRHotspots;
            document.getElementById('vr-hotspots-chk').addEventListener('change', e => {
                settings.showVRHotspots = e.target.checked;
                updateVRHotspotsVisibility();
                saveSettings();
            });

            document.getElementById('live-toggle').checked = settings.live;
            document.getElementById('live-toggle').addEventListener('change', e => {
                settings.live = e.target.checked;
                saveSettings();
            });

            // Toolbar Buttons
            const gridBtn = document.getElementById('toggle-grid-btn');
            gridBtn.addEventListener('click', () => {
                settings.showGrid = !settings.showGrid;
                worldGrid.visible = settings.showGrid;
                worldAxes.visible = settings.showGrid;
                gridBtn.classList.toggle('active', settings.showGrid);
                saveSettings();
            });

            // Set initial state from settings
            worldGrid.visible = settings.showGrid;
            worldAxes.visible = settings.showGrid;
            gridBtn.classList.toggle('active', settings.showGrid);

            const skelBtn = document.getElementById('toggle-skeleton-btn');
            skelBtn.addEventListener('click', () => {
                const vis = !skelBtn.classList.contains('active');
                skelBtn.classList.toggle('active', vis);
                skeletonHelpers.forEach(h => h.visible = vis);
                // Also update logic for unhideAllMeshes references if needed, 
                // but simpler to just use class check primarily or store in a var
            });

            // Settings Popup
            const setBtn = document.getElementById('settings-btn');
            const setPop = document.getElementById('settings-popup');

            setPop.addEventListener('mousedown', (e) => e.stopPropagation());
            setBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                screenshotPop.classList.add('hidden'); // Close other popup
                screenshotBtn.classList.remove('active');

                setPop.classList.toggle('hidden');
                setBtn.classList.toggle('active', !setPop.classList.contains('hidden'));
            });

            // Screenshot Popup
            const screenshotBtn = document.getElementById('screenshot-tool-btn');
            const screenshotPop = document.getElementById('screenshot-popup');
            const capture1x = document.getElementById('ss-capture-1x');
            const capture2x = document.getElementById('ss-capture-2x');

            screenshotPop.addEventListener('mousedown', (e) => e.stopPropagation());
            screenshotBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                setPop.classList.add('hidden'); // Close other popup
                setBtn.classList.remove('active');

                screenshotPop.classList.toggle('hidden');
                screenshotBtn.classList.toggle('active', !screenshotPop.classList.contains('hidden'));
            });

            const performCapture = (multiplier) => {
                settings.ssMultiplier = multiplier;
                takeScreenshot();
                screenshotPop.classList.add('hidden');
                screenshotBtn.classList.remove('active');
            };

            capture1x.addEventListener('click', (e) => { e.stopPropagation(); performCapture(1); });
            capture2x.addEventListener('click', (e) => { e.stopPropagation(); performCapture(2); });

            // Shortcuts Popup
            const shortcutsBtn = document.getElementById('shortcuts-btn');
            const shortcutsOverlay = document.getElementById('shortcuts-overlay');
            const closeShortcuts = document.getElementById('close-shortcuts');

            shortcutsBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                shortcutsOverlay.classList.add('active');
            });

            closeShortcuts.addEventListener('click', () => {
                shortcutsOverlay.classList.remove('active');
            });

            shortcutsOverlay.addEventListener('click', (e) => {
                if (e.target === shortcutsOverlay) {
                    shortcutsOverlay.classList.remove('active');
                }
            });

            // Close on Escape
            window.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    shortcutsOverlay.classList.remove('active');
                }
            });

            // Screenshot Settings Binding
            const ssBgMode = document.getElementById('ss-bg-mode');
            const colorPre1 = document.getElementById('ss-color-preview-1');
            const colorIn1 = document.getElementById('ss-color-input-1');
            const colorPre2 = document.getElementById('ss-color-preview-2');
            const colorIn2 = document.getElementById('ss-color-input-2');

            const updateColorUI = () => {
                const mode = ssBgMode.value;
                colorPre1.style.display = (mode === 'solid' || mode === 'gradient') ? '' : 'none';
                colorPre2.style.display = (mode === 'gradient') ? '' : 'none';

                colorPre1.style.backgroundColor = settings.ssBgColor1;
                colorIn1.value = settings.ssBgColor1;
                colorPre2.style.backgroundColor = settings.ssBgColor2;
                colorIn2.value = settings.ssBgColor2;
            };

            ssBgMode.value = settings.ssBgMode || 'transparent';
            ssBgMode.addEventListener('change', (e) => {
                settings.ssBgMode = e.target.value;
                updateColorUI();
                saveSettings();
            });

            colorPre1.addEventListener('click', () => colorIn1.click());
            colorIn1.addEventListener('input', (e) => {
                settings.ssBgColor1 = e.target.value;
                colorPre1.style.backgroundColor = settings.ssBgColor1;
                saveSettings();
            });

            colorPre2.addEventListener('click', () => colorIn2.click());
            colorIn2.addEventListener('input', (e) => {
                settings.ssBgColor2 = e.target.value;
                colorPre2.style.backgroundColor = settings.ssBgColor2;
                saveSettings();
            });

            updateColorUI();

            document.getElementById('restore-defaults-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                if (confirm('Restore all settings to default?')) {
                    Object.assign(settings, defaultSettings);

                    // Update UI elements
                    setVal('mat-rough', settings.rough);
                    setVal('mat-metal', settings.metal);
                    setVal('mat-lit', settings.lit);
                    setVal('cam-exposure', settings.exposure);
                    setVal('env-intensity', settings.envIntensity);
                    setVal('env-rotation', settings.rotation);
                    setVal('env-hdr-select', settings.hdr);
                    document.getElementById('env-bg-chk').checked = settings.showBackground;
                    document.getElementById('show-disabled-chk').checked = settings.showDisabled;
                    document.getElementById('vr-hotspots-chk').checked = settings.showVRHotspots;
                    ssBgMode.value = settings.ssBgMode;
                    colorIn1.value = settings.ssBgColor1;
                    colorIn2.value = settings.ssBgColor2;

                    // Trigger Updates
                    renderer.toneMappingExposure = settings.exposure;
                    scene.environmentIntensity = settings.envIntensity;
                    const rad = settings.rotation * (Math.PI / 180);
                    scene.backgroundRotation.y = rad;
                    scene.environmentRotation.y = rad;

                    updateMaterialProperties();
                    updateBackground();
                    updateDisabledVisibility();
                    updateVRHotspotsVisibility();
                    applyHDR();
                    updateColorUI();

                    // Reset Grid State
                    worldGrid.visible = settings.showGrid;
                    worldAxes.visible = settings.showGrid;
                    document.getElementById('toggle-grid-btn').classList.toggle('active', settings.showGrid);

                    saveSettings();
                }
            });

            // Close popups on click outside
            window.addEventListener('click', (e) => {
                if (!setPop.contains(e.target) && e.target !== setBtn && !setBtn.contains(e.target)) {
                    setPop.classList.add('hidden');
                    setBtn.classList.remove('active');
                }
                if (!screenshotPop.contains(e.target) && e.target !== screenshotBtn && !screenshotBtn.contains(e.target)) {
                    screenshotPop.classList.add('hidden');
                    screenshotBtn.classList.remove('active');
                }
            });

            // Selection Panel Controls
            document.getElementById('close-selection-btn').addEventListener('click', (e) => {
                document.getElementById('selection-panel').classList.remove('active');
            });

            document.getElementById('sel-manip-copy-btn').addEventListener('click', (e) => {
                const text = document.getElementById('sel-manip-dref').textContent;
                if (text && text !== 'N/A') {
                    navigator.clipboard.writeText(text);
                    showToast('DataRef copied!');
                }
            });
        }

        async function applyHDR() {
            if (settings.hdr === 'studio') {
                if (scene.environment && scene.environment.dispose) scene.environment.dispose();
                scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
                updateBackground();
            } else {
                let url = '';
                // Using verified URLs from Three.js examples repository
                if (settings.hdr === 'venice') url = 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/equirectangular/venice_sunset_1k.hdr';
                if (settings.hdr === 'overpass') url = 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/equirectangular/pedestrian_overpass_1k.hdr';

                if (url) {
                    try {
                        await loadHDRI(url);
                    } catch (e) {
                        console.error("Failed to load HDR, falling back to studio", e);
                        settings.hdr = 'studio';
                        const el = document.getElementById('env-hdr-select');
                        if (el) el.value = 'studio';
                        applyHDR();
                    }
                }
            }
        }

        function updateBackground() {
            if (settings.showBackground && scene.environment) {
                scene.background = scene.environment;
            } else {
                scene.background = new THREE.Color(0x121212);
            }
        }

        function loadHDRI(url) {
            return new Promise((resolve, reject) => {
                new RGBELoader()
                    .load(url, function (texture) {
                        texture.mapping = THREE.EquirectangularReflectionMapping;
                        const envMap = pmremGenerator.fromEquirectangular(texture).texture;

                        if (scene.environment && scene.environment.dispose) scene.environment.dispose();
                        scene.environment = envMap;
                        scene.environmentIntensity = settings.envIntensity;

                        texture.dispose(); // Original texture is no longer needed after PMREM

                        updateBackground();
                        resolve(envMap);
                    }, undefined, (err) => {
                        console.error("Error loading HDRI:", err);
                        reject(err);
                    });
            });
        }

        function onClick(event) {
            if (event.target !== renderer.domElement) return;

            // Check if we moved significant distance (likely panning)
            const dx = event.clientX - mouseDownPos.x;
            const dy = event.clientY - mouseDownPos.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > 5) return;

            if (event.button === 2) { // Right click
                deselectMesh();
                return;
            }

            if (event.button !== 0) return; // Only left click for selection

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Filter out selection helpers and non-visible meshes from raycasting
            const intersects = raycaster.intersectObjects(rootGroup.children, true).filter(i => {
                const isSystem = i.object.userData?.isSystem || i.object.userData?.isVRHotspot;
                if (i.object._isSelectionHelper || i.object.type !== 'Mesh' || isSystem) return false;

                // If in manipulators mode, only allow selecting meshes that have a manip
                if (currentViewMode === 'manipulators' && !i.object.userData.manip) return false;

                let curr = i.object;
                while (curr && curr !== scene) {
                    if (!curr.visible) return false;
                    curr = curr.parent;
                }
                return true;
            });

            if (intersects.length > 0) {
                // Unique the meshes in intersects to avoid cycling through multiple hits on the same mesh
                const uniqueIntersects = [];
                const seen = new Set();
                for (const hit of intersects) {
                    if (!seen.has(hit.object)) {
                        seen.add(hit.object);
                        uniqueIntersects.push(hit);
                    }
                }

                let meshToSelect = uniqueIntersects[0].object;

                // Cycle logic: if we are clicking and NOT using shift, and the current selection is one of the intersected meshes
                if (!event.shiftKey && selectedMeshes.length === 1) {
                    const currentIdx = uniqueIntersects.findIndex(i => i.object === selectedMeshes[0]);
                    if (currentIdx !== -1) {
                        meshToSelect = uniqueIntersects[(currentIdx + 1) % uniqueIntersects.length].object;
                    }
                }

                selectMesh(meshToSelect, event.shiftKey);
            } else {
                if (!event.shiftKey) deselectMesh();
            }
        }

        function selectMesh(mesh, append = false) {
            if (!append) {
                if (selectedMeshes.length === 1 && selectedMeshes[0] === mesh) {
                    deselectMesh();
                    return;
                }
                deselectMesh();
                selectedMeshes = [mesh];
            } else {
                const idx = selectedMeshes.indexOf(mesh);
                if (idx > -1) {
                    removeHighlight(mesh);
                    selectedMeshes.splice(idx, 1);
                    updateDataRefVisibility();
                    updateStats();
                    updateObjectListSelection();
                    return;
                }
                selectedMeshes.push(mesh);
            }

            addHighlight(mesh);
            updateDataRefVisibility();
            updateStats();
            updateObjectListSelection();

            // Store last clicked index for range selection from 3D viewport
            let curr = mesh;
            while (curr && curr.parent !== rootGroup) curr = curr.parent;
            if (curr) {
                const idx = loadedObjects.findIndex(rec => rec.group === curr);
                if (idx !== -1) lastClickedObjIndex = idx;
            }

            // Manipulator Info Panel Update
            if (selectedMeshes.length === 1 && mesh.userData.manip) {
                updateManipulatorPanel(mesh);
            } else {
                if (!append) document.getElementById('selection-panel').classList.remove('active');
            }
        }

        function updateManipulatorPanel(mesh) {
            const panel = document.getElementById('selection-panel');
            const m = mesh.userData.manip;
            document.getElementById('sel-manip-type').textContent = m.type || 'Unknown';

            const labelText = document.getElementById('sel-manip-label-text');
            if (labelText) labelText.textContent = m.isCommand ? 'Command' : 'DataRef';

            const drefContainer = document.getElementById('sel-manip-dref');
            const rawDref = m.dref || 'N/A';

            // Check for multiple datarefs (split by comma ONLY)
            const drefs = rawDref.split(',').map(d => d.trim()).filter(d => d.length > 0 && d !== 'N/A');

            drefContainer.innerHTML = ''; // Clear existing text

            drefs.forEach(d => {
                const row = document.createElement('div');
                row.style.display = 'flex';
                row.style.alignItems = 'center';
                row.style.justifyContent = 'space-between';
                row.style.marginBottom = '4px';
                row.style.background = 'rgba(255,255,255,0.05)';
                row.style.padding = '2px 4px';
                row.style.borderRadius = '4px';

                const text = document.createElement('span');
                text.textContent = d;
                text.style.wordBreak = 'break-all';
                text.style.marginRight = '6px';
                text.style.color = '#4db8ff'; // Accent color

                const btn = document.createElement('span');
                btn.className = 'material-symbols-outlined icon-btn';
                btn.textContent = 'content_copy';
                btn.style.fontSize = '14px';
                btn.title = 'Copy this DataRef';
                btn.style.cursor = 'pointer';
                btn.style.opacity = '0.7';

                btn.onmouseover = () => btn.style.opacity = '1';
                btn.onmouseout = () => btn.style.opacity = '0.7';

                btn.onclick = (e) => {
                    e.stopPropagation();
                    navigator.clipboard.writeText(d);
                    showToast('Copied: ' + d);
                };

                row.appendChild(text);
                row.appendChild(btn);
                drefContainer.appendChild(row);
            });

            // Hide main header copy button as we ALWAYS have individual ones now
            const mainCopyBtn = document.getElementById('sel-manip-copy-btn');
            if (mainCopyBtn) mainCopyBtn.style.display = 'none';

            const ttRow = document.getElementById('sel-manip-tooltip-row');
            if (m.tooltip && m.tooltip.trim().length > 0) {
                document.getElementById('sel-manip-tooltip').textContent = m.tooltip;
                ttRow.style.display = 'flex';
            } else {
                ttRow.style.display = 'none';
            }

            panel.classList.add('active');
        }

        function addHighlight(mesh) {
            if (mesh._selectionHelper) return;

            // Create an overlay highlight that works in all modes
            const mat = new THREE.MeshBasicMaterial({
                color: 0x4db8ff,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide,
                depthTest: true,
                polygonOffset: true,
                polygonOffsetFactor: -4,
                polygonOffsetUnits: -4
            });

            const helper = new THREE.Mesh(mesh.geometry, mat);
            helper._isSelectionHelper = true;
            mesh.add(helper);
            mesh._selectionHelper = helper;
        }

        function removeHighlight(mesh) {
            if (mesh._selectionHelper) {
                mesh.remove(mesh._selectionHelper);
                if (mesh._selectionHelper.geometry && mesh._selectionHelper.geometry !== mesh.geometry) {
                    mesh._selectionHelper.geometry.dispose();
                }
                if (mesh._selectionHelper.material) {
                    mesh._selectionHelper.material.dispose();
                }
                mesh._selectionHelper = null;
            }
        }

        function deselectMesh() {
            selectedMeshes.forEach(m => removeHighlight(m));
            selectedMeshes = [];
            updateDataRefVisibility();
            updateStats();
            updateObjectListSelection();
            document.getElementById('selection-panel').classList.remove('active');
        }

        function selectMeshesByDataRef(drefName) {
            deselectMesh(); // Clear current selection
            const meshesToSelect = new Set();
            animationControllers.forEach(ctrl => {
                if (ctrl.dref === drefName) {
                    ctrl.target.traverse(obj => {
                        if (obj.isMesh && !obj._isSelectionHelper) {
                            meshesToSelect.add(obj);
                        }
                    });
                }
            });

            meshesToSelect.forEach(mesh => {
                selectMesh(mesh, true); // true for append mode
            });
        }

        function updateObjectListSelection() {
            // First clear all
            loadedObjects.forEach(rec => rec.div.classList.remove('active-entry'));

            // Find objects involved in selection
            const activeGroups = new Set();
            selectedMeshes.forEach(m => {
                let curr = m;
                while (curr && curr.parent !== rootGroup) {
                    curr = curr.parent;
                }
                if (curr) activeGroups.add(curr);
            });

            loadedObjects.forEach(rec => {
                if (activeGroups.has(rec.group)) {
                    rec.div.classList.add('active-entry');
                    rec.div.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                }
            });
        }

        function handleObjectListClick(index, shift, ctrl) {
            if (index < 0 || index >= loadedObjects.length) return;

            if (shift && lastClickedObjIndex !== -1) {
                const start = Math.min(index, lastClickedObjIndex);
                const end = Math.max(index, lastClickedObjIndex);

                if (!ctrl) {
                    // Standard shift-click replaces selection
                    selectedMeshes.forEach(m => removeHighlight(m));
                    selectedMeshes = [];
                }

                for (let i = start; i <= end; i++) {
                    selectObjectMeshes(loadedObjects[i], true);
                }
            } else if (ctrl) {
                toggleObjectMeshes(loadedObjects[index]);
            } else {
                selectedMeshes.forEach(m => removeHighlight(m));
                selectedMeshes = [];
                selectObjectMeshes(loadedObjects[index], true);
            }

            lastClickedObjIndex = index;
            updateObjectListSelection();
            updateDataRefVisibility();
            updateStats();

            // Handle manipulator panel
            const panel = document.getElementById('selection-panel');
            if (selectedMeshes.length === 1 && selectedMeshes[0].userData.manip) {
                updateManipulatorPanel(selectedMeshes[0]);
            } else {
                panel.classList.remove('active');
            }
        }

        function selectObjectMeshes(rec, append = false) {
            if (!append) {
                selectedMeshes.forEach(m => removeHighlight(m));
                selectedMeshes = [];
            }

            rec.group.traverse(o => {
                if (o.isMesh && !o._isSelectionHelper && !o.userData?.isSystem) {
                    if (!selectedMeshes.includes(o)) {
                        selectedMeshes.push(o);
                        addHighlight(o);
                    }
                }
            });
        }

        function toggleObjectMeshes(rec) {
            const meshes = [];
            rec.group.traverse(o => {
                if (o.isMesh && !o._isSelectionHelper && !o.userData?.isSystem) {
                    meshes.push(o);
                }
            });

            // If ANY mesh of the object is selected, deselect all. Otherwise select all.
            const anySelected = meshes.some(m => selectedMeshes.includes(m));

            if (anySelected) {
                meshes.forEach(m => {
                    const idx = selectedMeshes.indexOf(m);
                    if (idx > -1) {
                        removeHighlight(m);
                        selectedMeshes.splice(idx, 1);
                    }
                });
            } else {
                meshes.forEach(m => {
                    if (!selectedMeshes.includes(m)) {
                        selectedMeshes.push(m);
                        addHighlight(m);
                    }
                });
            }
        }

        let lastVisibilityMap = null;

        function isolateSelectedMesh() {
            if (lastVisibilityMap) {
                // Restore previous state
                rootGroup.traverse(o => {
                    if (o.isMesh && !o._isSelectionHelper && lastVisibilityMap.has(o)) {
                        o.visible = lastVisibilityMap.get(o);
                    }
                });
                lastVisibilityMap = null;
            } else if (selectedMeshes.length > 0) {
                // Isolate
                lastVisibilityMap = new Map();
                const toKeep = new Set(selectedMeshes);
                rootGroup.traverse(o => {
                    const isSystem = o.userData?.isSystem || o.userData?.isVRHotspot;
                    if (o.isMesh && !o._isSelectionHelper && !isSystem) {
                        lastVisibilityMap.set(o, o.visible);
                        o.visible = toKeep.has(o);
                    }
                });
            }
            updateDataRefVisibility();
        }

        function hideSelectedMesh() {
            if (selectedMeshes.length > 0) {
                selectedMeshes.forEach(m => m.visible = false);
                deselectMesh();
            }
        }

        function updateVisibility() {
            const showSkeleton = document.getElementById('toggle-skeleton-btn').classList.contains('active');
            const isSoloActive = soloObjects.size > 0;

            // Update Skeletons
            skeletonHelpers.forEach(h => h.visible = showSkeleton);

            // Update Groups based on Solo/Record state
            loadedObjects.forEach(record => {
                let shouldShow = record.visible;
                if (isSoloActive) {
                    shouldShow = soloObjects.has(record);
                }
                record.group.visible = shouldShow;

                // Visual feedback in list
                if (isSoloActive) {
                    record.div.style.opacity = soloObjects.has(record) ? '1' : '0.5';
                } else {
                    record.div.style.opacity = record.visible ? '1' : '0.5';
                }
            });

            updateStats();
            updateDataRefVisibility();
        }

        function updateDisabledVisibility() {
            rootGroup.traverse(obj => {
                if (obj.isMesh && obj._drawEnabled === false) {
                    obj.visible = (currentViewMode === 'manipulators') || settings.showDisabled;
                }
            });
        }

        function updateVRHotspotsVisibility() {
            if (vrHotspotsGroup) {
                vrHotspotsGroup.visible = settings.showVRHotspots;
            }
        }

        function unhideAllMeshes() {
            // User requested to ONLY unhide meshes (the ones hidden with H), 
            // NOT objects (the ones hidden with the Eye icon or excluded by Solo).

            lastVisibilityMap = null;

            // 1. Reset all Meshes (in case individual meshes were hidden via 'Hide Selected')
            rootGroup.traverse(o => {
                if (o.isMesh && !o._isSelectionHelper) {
                    if (o._drawEnabled === false) {
                        o.visible = settings.showDisabled;
                    } else {
                        o.visible = true;
                    }
                }
            });

            // 2. Re-apply Object-level visibility (keeps hidden objects hidden)
            updateVisibility();
        }

        function resetViewer() {
            rootGroup.clear();
            skeletonHelpers = [];
            animationControllers = [];
            datarefRanges.clear();
            guiData = {};
            guiControllers = [];
            loadedObjects = [];
            soloObjects.clear();
            fileHandleMap.clear();
            lastVisibilityMap = null;
            vrHotspotsGroup = null;
            lastClickedObjIndex = -1;

            materialCache.clear();
            loadedTextures.clear();

            filesLoadedCount = 0;

            document.getElementById('obj-list-container').innerHTML = '';
            document.getElementById('dref-search').value = '';
            deselectMesh();

            if (gui) {
                // Clear all controllers and folders from the GUI
                [...gui.folders].forEach(f => f.destroy());
                [...gui.controllers].forEach(c => c.destroy());
            }

            document.getElementById('upload-overlay').classList.remove('hidden');
            document.getElementById('sidebar').classList.add('hidden-ui');
            document.getElementById('ui-right-container').classList.add('hidden-ui');
            document.getElementById('viewport-toolbar').classList.add('hidden-ui');
            document.getElementById('stats-overlay').classList.add('hidden-ui');
            updateStats();
        }

        async function handleDrop(e) {
            e.preventDefault();
            document.getElementById('drop-target').style.borderColor = '#555';

            const files = [];

            const processEntry = async (entry) => {
                if (entry.kind === 'file') {
                    const file = await entry.getFile();
                    fileHandleMap.set(file.name, { handle: entry, lastModified: file.lastModified, size: file.size });
                    files.push(file);
                    if (!lastUsedHandle) lastUsedHandle = entry;
                } else if (entry.kind === 'directory') {
                    // Store directory handle to monitor for new/replaced files
                    fileHandleMap.set(entry.name, { handle: entry, isDirectory: true });
                    lastUsedHandle = entry;
                    for await (const childEntry of entry.values()) {
                        await processEntry(childEntry);
                    }
                }
            };

            if (e.dataTransfer.items) {
                for (const item of e.dataTransfer.items) {
                    if (item.kind === 'file') {
                        if (typeof item.getAsFileSystemHandle === 'function') {
                            const handle = await item.getAsFileSystemHandle();
                            if (handle) await processEntry(handle);
                            continue;
                        }
                        const file = item.getAsFile();
                        if (file) files.push(file);
                    }
                }
            } else if (e.dataTransfer.files.length) {
                for (const file of e.dataTransfer.files) {
                    files.push(file);
                }
            }

            if (files.length) processFiles(files);
        }
        function handleFile(e) { if (e.target.files.length) processFiles(e.target.files); }

        function loadTextureFile(file) {
            return new Promise((resolve) => {
                const texLoader = new THREE.TextureLoader();
                const ddsLoader = new DDSLoader();
                const url = URL.createObjectURL(file);
                const isDDS = file.name.toLowerCase().endsWith('.dds');
                const loader = isDDS ? ddsLoader : texLoader;

                loader.load(url, (tex) => {
                    const isNormalMap = file.name.toLowerCase().includes('_nrm');
                    const isMatMap = file.name.toLowerCase().includes('_mat');
                    tex.colorSpace = (isNormalMap || isMatMap) ? THREE.NoColorSpace : THREE.SRGBColorSpace;
                    tex.name = file.name.toLowerCase();
                    tex.anisotropy = renderer.capabilities.getMaxAnisotropy();

                    if (!isDDS) {
                        tex.flipY = true;
                        tex.wrapS = THREE.RepeatWrapping;
                        tex.wrapT = THREE.RepeatWrapping;
                    } else {
                        tex.wrapS = THREE.RepeatWrapping;
                        tex.wrapT = THREE.RepeatWrapping;
                        tex.repeat.y = -1;
                        tex.offset.y = 1;
                    }

                    loadedTextures.set(file.name.toLowerCase(), tex);
                    URL.revokeObjectURL(url);
                    resolve(tex);
                }, undefined, (err) => {
                    console.warn(`Error loading texture ${file.name}:`, err);
                    URL.revokeObjectURL(url);
                    resolve(null);
                });
            });
        }

        async function processFiles(files, silent = false) {
            if (filesLoadedCount === 0) {
                document.getElementById('upload-overlay').classList.add('hidden');
                document.getElementById('sidebar').classList.remove('hidden-ui');
                document.getElementById('ui-right-container').classList.remove('hidden-ui');
            }

            const fileList = Array.from(files);
            const texLoader = new THREE.TextureLoader();
            const ddsLoader = new DDSLoader();

            // Show loading bar
            const loadingContainer = document.getElementById('loading-bar-container');
            const loadingFill = document.getElementById('loading-bar-fill');
            const loadingText = document.getElementById('loading-bar-text');
            const viewport = document.getElementById('viewport');

            if (!silent) {
                loadingContainer.classList.add('active');
                viewport.classList.add('loading');
            }

            // Count total files to load
            const hdrFiles = fileList.filter(f => f.name.toLowerCase().endsWith('.hdr'));
            const imgFiles = fileList.filter(f => /\.(png|jpg|jpeg|bmp|dds)$/i.test(f.name));
            const objFiles = fileList.filter(f => f.name.toLowerCase().endsWith('.obj'));
            const totalFiles = hdrFiles.length + imgFiles.length + objFiles.length;
            let loadedFiles = 0;

            const updateProgress = () => {
                if (silent) return;
                const percent = (loadedFiles / totalFiles) * 100;
                loadingFill.style.width = percent + '%';
                loadingText.textContent = `${loadedFiles} / ${totalFiles}`;
            };

            updateProgress();

            // 0. Process HDRs
            for (const f of hdrFiles) {
                const url = URL.createObjectURL(f);
                await loadHDRI(url);
                URL.revokeObjectURL(url);
                loadedFiles++;
                updateProgress();
            }

            // 1. Identify and load images first
            const texPromises = imgFiles.map(async f => {
                await loadTextureFile(f);
                loadedFiles++;
                updateProgress();
            });

            await Promise.all(texPromises);

            // 2. Process OBJs
            for (const file of objFiles) {
                const text = await file.text();

                // Check if this file has a stored scene name (from ACF loading)
                const fileInfo = fileHandleMap.get(file.name);
                const sceneName = fileInfo?.sceneName || file.name;

                parseOBJ8(text, sceneName);

                // Update guiData for new animations immediately so they render correctly during loading
                animationControllers.forEach(ctrl => {
                    if (ctrl.dref && guiData[ctrl.dref] === undefined) {
                        guiData[ctrl.dref] = 0;
                    }
                });

                loadedFiles++;
                updateProgress();
                // Recenter camera after each object is loaded
                if (!silent) centerCamera();
            }

            // 3. Finalize UI and View
            buildGUI();
            refreshMaterials(); // Ensure any newly loaded textures are applied to existing meshes
            updateStats();

            // Hide loading bar, remove blur, and center camera after scene updates
            if (!silent) {
                setTimeout(() => {
                    loadingContainer.classList.remove('active');
                    viewport.classList.remove('loading');
                    centerCamera();
                }, 500);
            }
        }

        // --- ACF HANDLING ---
        async function openACFFolder() {
            if (!window.showDirectoryPicker) {
                alert("Your browser does not support the File System Access API (showDirectoryPicker).");
                return;
            }

            try {
                const pickerOptions = { id: 'acf_folder', mode: 'read' };
                if (lastUsedHandle) pickerOptions.startIn = lastUsedHandle;

                const dirHandle = await window.showDirectoryPicker(pickerOptions);
                lastUsedHandle = dirHandle;

                // 1. Find .acf files
                const acfFiles = [];
                for await (const entry of dirHandle.values()) {
                    if (entry.kind === 'file' && entry.name.toLowerCase().endsWith('.acf')) {
                        acfFiles.push(entry);
                    }
                }

                if (acfFiles.length === 0) {
                    alert("No .acf files found in this folder.");
                    return;
                }

                if (acfFiles.length === 1) {
                    loadACF(acfFiles[0], dirHandle);
                } else {
                    showACFSelection(acfFiles, dirHandle);
                }

            } catch (err) {
                if (err.name !== 'AbortError') console.error("Error opening folder:", err);
            }
        }

        function showACFSelection(files, dirHandle) {
            const overlay = document.getElementById('acf-selection-overlay');
            const list = document.getElementById('acf-list');
            list.innerHTML = '';

            files.forEach(file => {
                const btn = document.createElement('button');
                btn.className = 'btn';
                btn.textContent = file.name;
                btn.onclick = () => {
                    overlay.classList.add('hidden-ui');
                    loadACF(file, dirHandle);
                };
                list.appendChild(btn);
            });

            overlay.classList.remove('hidden-ui');
        }

        async function loadACF(fileHandle, dirHandle) {
            const loadingContainer = document.getElementById('loading-bar-container');
            const loadingFill = document.getElementById('loading-bar-fill');
            const loadingText = document.getElementById('loading-bar-text');
            const viewport = document.getElementById('viewport');

            try {
                const file = await fileHandle.getFile();
                const text = await file.text();
                const objects = parseACF(text);

                if (objects.length === 0) {
                    alert("No attached objects found in " + file.name);
                    return;
                }

                resetViewer();

                loadingContainer.classList.add('active');
                viewport.classList.add('loading');
                document.getElementById('upload-overlay').classList.add('hidden');
                document.getElementById('sidebar').classList.remove('hidden-ui');
                document.getElementById('ui-right-container').classList.remove('hidden-ui');
                document.getElementById('viewport-toolbar').classList.remove('hidden-ui');
                document.getElementById('stats-overlay').classList.remove('hidden-ui');

                let loadedCount = 0;
                const total = objects.length;

                for (const objDef of objects) {
                    loadingText.textContent = `Loading ${objDef.file} (${loadedCount}/${total})`;
                    loadingFill.style.width = ((loadedCount / total) * 100) + '%';

                    try {
                        let objFileHandle = await findObjectFile(dirHandle, objDef.file);

                        if (objFileHandle) {
                            const objFile = await objFileHandle.getFile();

                            // Use index prefix to ensure uniqueness internally
                            const cleanName = objDef.file.split(/[/\\]/).pop();
                            const uniqueName = `${objDef.index}_${cleanName}`;

                            // Store with unique name for live reload matching
                            fileHandleMap.set(objFile.name, {
                                handle: objFileHandle,
                                lastModified: objFile.lastModified,
                                size: objFile.size,
                                sceneName: uniqueName // Store the name used in the scene
                            });

                            const objText = await objFile.text();

                            // Load referenced textures
                            await loadReferencedTextures(objText, dirHandle, objDef.file);

                            parseOBJ8(objText, uniqueName, cleanName);

                            const rec = loadedObjects[loadedObjects.length - 1];
                            if (rec) {
                                // Position (ACF Coords -> Three.js)
                                // X-Plane: X=Right, Y=Up, Z=Aft
                                // Three.js: X=Right, Y=Up, Z=Back (towards viewer)
                                // Coordinate systems align for visualization if we treat +Z as Aft.
                                rec.group.position.set(objDef.pos.x, objDef.pos.y, objDef.pos.z);

                                // Rotation (Euler YXZ: Yaw, Pitch, Roll)
                                const d2r = Math.PI / 180;
                                const rot = new THREE.Euler(
                                    objDef.rot.theta * d2r,
                                    objDef.rot.psi * d2r,
                                    objDef.rot.phi * d2r,
                                    'YXZ'
                                );
                                rec.group.rotation.copy(rot);
                            }
                        } else {
                            console.warn("Could not find object file:", objDef.file);
                        }

                    } catch (e) {
                        console.error("Error loading object:", objDef.file, e);
                    }
                    loadedCount++;
                    updateStats();

                    // Initialize guiData for new animations after each object to ensure animations update during load
                    animationControllers.forEach(ctrl => {
                        if (ctrl.dref && guiData[ctrl.dref] === undefined) {
                            guiData[ctrl.dref] = 0;
                        }
                    });
                }

                buildGUI();

                await loadVRConfig(dirHandle, file);

                centerCamera();
                refreshMaterials();

                setTimeout(() => {
                    loadingContainer.classList.remove('active');
                    viewport.classList.remove('loading');
                }, 500);

            } catch (err) {
                console.error("Error loading ACF:", err);
                alert("Error loading ACF file. See console.");
                loadingContainer.classList.remove('active');
                viewport.classList.remove('loading');
            }
        }

        async function findObjectFile(dirHandle, filePath) {
            // Helper to try to get a handle with path normalization
            const tryPath = async (pathStr) => {
                // Normalize slashes and split
                const parts = pathStr.replace(/\\/g, '/').split('/').filter(p => p !== '' && p !== '.');

                // Filter out '..' to treat them as "root" or skip (clamping to root)
                const effectiveParts = [];
                for (let p of parts) {
                    if (p === '..') continue;
                    effectiveParts.push(p);
                }

                if (effectiveParts.length === 0) return null;

                let curr = dirHandle;
                // Traverse folders
                for (let i = 0; i < effectiveParts.length - 1; i++) {
                    try {
                        curr = await curr.getDirectoryHandle(effectiveParts[i]);
                    } catch (e) {
                        return null;
                    }
                }

                // Get File
                try {
                    return await curr.getFileHandle(effectiveParts[effectiveParts.length - 1]);
                } catch (e) {
                    return null;
                }
            };

            // 1. Try exact path (normalized)
            let handle = await tryPath(filePath);
            if (handle) return handle;

            // 2. Try adding 'objects/' prefix (if not already present)
            // Note: filePath might be something like "instruments/foo.obj". 
            // We want to try "objects/instruments/foo.obj".
            const lower = filePath.toLowerCase().replace(/\\/g, '/');
            if (!lower.startsWith('objects/')) {
                handle = await tryPath('objects/' + filePath);
                if (handle) return handle;
            }

            return null;
        }

        async function loadReferencedTextures(text, dirHandle, objPath) {
            console.log(`[TextureDebug] Scanning object: ${objPath}`);
            const lines = text.split(/\r?\n/);
            const textureNames = new Set();

            // Scan first 200 lines
            for (let i = 0; i < Math.min(lines.length, 200); i++) {
                const line = lines[i].split('#')[0].trim();
                const parts = line.split(/\s+/);
                const cmd = parts[0];
                if (['TEXTURE', 'TEXTURE_LIT', 'TEXTURE_NORMAL'].includes(cmd)) {
                    if (parts.length > 1) {
                        textureNames.add(parts[1]);
                        console.log(`[TextureDebug] Found command: ${cmd} ${parts[1]}`);
                    }
                } else if (cmd === 'TEXTURE_MAP') {
                    if (parts.length > 2) {
                        textureNames.add(parts[2]);
                        console.log(`[TextureDebug] Found command: TEXTURE_MAP ${parts[1]} ${parts[2]}`);
                    }
                }
            }

            // Determine directory of the OBJ file relative to root
            const objDir = objPath.replace(/\\/g, '/').includes('/') ? objPath.replace(/\\/g, '/').substring(0, objPath.replace(/\\/g, '/').lastIndexOf('/')) : '';
            console.log(`[TextureDebug] Object Directory: '${objDir}'`);

            const promises = [];
            for (const texName of textureNames) {
                // If it looks like a default or placeholder, skip?
                if (texName === 'none' || texName === 'default') continue;
                if (loadedTextures.has(texName.toLowerCase())) {
                    console.log(`[TextureDebug] Skipping already loaded: ${texName}`);
                    continue;
                }

                promises.push((async () => {
                    let handle = null;
                    const relativePath = objDir ? `${objDir}/${texName}` : texName;

                    console.log(`[TextureDebug] Looking for '${texName}'...`);

                    // 1. Try relative to OBJ
                    console.log(`[TextureDebug] Trying relative path: '${relativePath}'`);
                    handle = await findObjectFile(dirHandle, relativePath);

                    // 2. Try exact name in root / global lookup
                    if (!handle) {
                        console.log(`[TextureDebug] Trying root/exact path: '${texName}'`);
                        handle = await findObjectFile(dirHandle, texName);
                    }

                    // 3. Try fallback extensions
                    if (!handle) {
                        const exts = ['.dds', '.png', '.jpg', '.bmp'];
                        const baseName = texName.includes('.') ? texName.substring(0, texName.lastIndexOf('.')) : texName;
                        const relBaseName = relativePath.includes('.') ? relativePath.substring(0, relativePath.lastIndexOf('.')) : relativePath;

                        for (const ext of exts) {
                            // Skip if this is the extension we already tried
                            if (texName.toLowerCase().endsWith(ext)) continue;

                            console.log(`[TextureDebug] Trying fallback extension: '${relBaseName + ext}'`);
                            handle = await findObjectFile(dirHandle, relBaseName + ext);
                            if (handle) break;

                            console.log(`[TextureDebug] Trying fallback extension (root): '${baseName + ext}'`);
                            handle = await findObjectFile(dirHandle, baseName + ext);
                            if (handle) break;
                        }
                    }

                    if (handle) {
                        try {
                            console.log(`[TextureDebug] Found '${texName}'! Loading...`);
                            const file = await handle.getFile();
                            await loadTextureFile(file);
                        } catch (e) {
                            console.warn("[TextureDebug] Failed to load texture file", texName, e);
                        }
                    } else {
                        console.warn(`[TextureDebug] FAILED to find texture: '${texName}'`);
                    }
                })());
            }

            await Promise.all(promises);
        }

        async function loadVRConfig(dirHandle, acfFile) {
            const baseName = acfFile.name.replace(/\.[^/.]+$/, "");
            const configName = baseName + "_vrconfig.txt";
            const handle = await findObjectFile(dirHandle, configName);

            if (handle) {
                try {
                    const file = await handle.getFile();
                    // Register for live reload tracking
                    fileHandleMap.set(file.name, { handle: handle, lastModified: file.lastModified, size: file.size });

                    const text = await file.text();
                    const result = parseVRConfig(text);
                    if (result.hotspots.length > 0) {
                        drawHotspots(result);
                    }
                } catch (e) {
                    console.error("Error loading vrconfig:", e);
                }
            }
        }

        function parseVRConfig(text) {
            const lines = text.split(/\r?\n/);
            const hotspots = [];
            let current = null;
            let refPoint = null;

            lines.forEach(line => {
                const part = line.trim().split(/\s+/);
                const cmd = part[0];

                if (cmd === 'REF_POINT_ACF') {
                    // Override default CG offset with this reference point
                    // Format: RefX RefY RefZ (in meters? Doc says "1.0 -2.0")
                    // It says "If Y/Z blank...".
                    // Let's assume X Y Z.
                    if (part.length >= 4) {
                        refPoint = new THREE.Vector3(parseFloat(part[1]), parseFloat(part[2]), parseFloat(part[3]));
                    } else if (part.length >= 3) {
                        // Some docs imply only X Y Z? Or maybe just X Y?
                        // The example "1.0 -2.0" looks like 2 coordinates.
                        // Doc says "Y/Z coordinates blank". Implies X is first?
                        // "OLD CG was at Y/Z... add REF_POINT_ACF 1.0 -2.0... which is the old CG location".
                        // Wait, X-Plane coordinates are X, Y, Z.
                        // Maybe it expects X Y Z.
                        refPoint = new THREE.Vector3(parseFloat(part[1]), parseFloat(part[2]), 0.0);
                    }
                } else if (cmd === 'BEGIN_TELEPORT_HOTSPOT') {
                    current = { name: part.slice(2).join(" "), aabb: null, pos: null, rot: { psi: 0, theta: 0, phi: 0 } };
                } else if (cmd === 'END_TELEPORT_HOTSPOT') {
                    if (current) hotspots.push(current);
                    current = null;
                } else if (current) {
                    if (cmd === 'AABB') {
                        // Standard: minX, minY, minZ, maxX, maxY, maxZ
                        current.aabb = {
                            min: new THREE.Vector3(parseFloat(part[1]), parseFloat(part[2]), parseFloat(part[3])),
                            max: new THREE.Vector3(parseFloat(part[4]), parseFloat(part[5]), parseFloat(part[6]))
                        };
                    } else if (cmd === 'PRESET_XYZ') {
                        current.pos = new THREE.Vector3(parseFloat(part[1]), parseFloat(part[2]), parseFloat(part[3]));
                    } else if (cmd === 'PRESET_PSI') {
                        current.rot.psi = parseFloat(part[1]);
                    } else if (cmd === 'PRESET_THE') {
                        current.rot.theta = parseFloat(part[1]);
                    } else if (cmd === 'PRESET_PHI') {
                        current.rot.phi = parseFloat(part[1]);
                    }
                }
            });
            return { hotspots, refPoint };
        }

        function drawHotspots({ hotspots, refPoint }) {
            // Clean up old group
            if (vrHotspotsGroup) {
                rootGroup.remove(vrHotspotsGroup);
                vrHotspotsGroup = null;
            }

            vrHotspotsGroup = new THREE.Group();
            vrHotspotsGroup.name = "VR_Hotspots_System";
            rootGroup.add(vrHotspotsGroup);

            // Determine Offset: RefPoint > ACF_CG > (0,0,0)
            // If refPoint is present, hotspots are relative to it.
            // If not, they are relative to CG.
            // In both cases, we need to add this offset to the hotspot coords to get "Authoring Space" coords (which Three.js scene uses).
            const offset = refPoint || acfCgOffset;
            console.log("Applying VR Offset:", offset);

            const d2r = Math.PI / 180;
            const getVibrantColor = () => {
                const c = new THREE.Color();
                c.setHSL(Math.random(), 1.0, 0.5); // Vibrant colors
                return c;
            };

            hotspots.forEach(h => {
                // Generate a random color for this entire hotspot group
                const hpColor = getVibrantColor();
                const aabbMat = new THREE.MeshBasicMaterial({ color: hpColor, transparent: true, opacity: 0.15, depthWrite: false, side: THREE.DoubleSide });
                const edgesMat = new THREE.LineBasicMaterial({ color: hpColor });
                // Marker needs to be visible, so opaque basic material
                const markerMat = new THREE.MeshBasicMaterial({ color: hpColor });
                const arrowColor = hpColor;

                // Helper Group for this hotspot
                const hGroup = new THREE.Group();
                vrHotspotsGroup.add(hGroup);

                // AABB
                if (h.aabb) {
                    const min = h.aabb.min.clone().add(offset);
                    const max = h.aabb.max.clone().add(offset);

                    const width = max.x - min.x;
                    const height = max.y - min.y;
                    const depth = max.z - min.z;

                    // 1. Transparent Box
                    const boxGeo = new THREE.BoxGeometry(width, height, depth);
                    const box = new THREE.Mesh(boxGeo, aabbMat);

                    const cx = (min.x + max.x) / 2;
                    const cy = (min.y + max.y) / 2;
                    const cz = (min.z + max.z) / 2;

                    box.position.set(cx, cy, cz);
                    box.userData.isVRHotspotAABB = true;
                    hGroup.add(box);

                    // 2. Wireframe Edges
                    const edges = new THREE.EdgesGeometry(boxGeo);
                    const line = new THREE.LineSegments(edges, edgesMat);
                    line.position.copy(box.position);
                    hGroup.add(line);
                }

                // Preset View
                if (h.pos) {
                    const worldPos = h.pos.clone().add(offset);

                    // Marker - Smaller, visible size
                    const markerMatBright = new THREE.MeshBasicMaterial({
                        color: hpColor,
                        depthTest: false,
                        depthWrite: false
                    });
                    const marker = new THREE.Mesh(
                        new THREE.SphereGeometry(0.08, 16, 16),
                        markerMatBright
                    );
                    marker.position.copy(worldPos);
                    marker.name = h.name;
                    marker.renderOrder = 999; // Render on top
                    marker.userData.isVRHotspot = true;
                    marker.userData.isSystem = true;
                    hGroup.add(marker);

                    // Orientation Arrow
                    const rot = new THREE.Euler(
                        h.rot.theta * d2r,
                        -h.rot.psi * d2r,
                        h.rot.phi * d2r,
                        'YXZ'
                    );

                    const dir = new THREE.Vector3(0, 0, -1);
                    dir.applyEuler(rot);

                    // Longer arrow for clarity
                    const arrow = new THREE.ArrowHelper(dir, worldPos, 0.6, hpColor, 0.2, 0.15);

                    // Force materials to be on top
                    arrow.line.material = new THREE.LineBasicMaterial({
                        color: hpColor,
                        depthTest: false,
                        depthWrite: false,
                        transparent: true,
                        opacity: 1.0
                    });
                    arrow.cone.material = new THREE.MeshBasicMaterial({
                        color: hpColor,
                        depthTest: false,
                        depthWrite: false,
                        transparent: true,
                        opacity: 1.0
                    });

                    arrow.renderOrder = 999;
                    hGroup.renderOrder = 999; // Ensure the whole subgroup is high priority
                    hGroup.add(arrow);
                }
            });

            // Mark EVERYTHING in the VR group as system/hotspot objects so the material system skips them
            vrHotspotsGroup.traverse(o => {
                if (!o.userData) o.userData = {};
                o.userData.isSystem = true;
                o.userData.isVRHotspot = true;
            });

            updateVRHotspotsVisibility();
            // registerObjectUI removed as per request for integration into Manipulators mode
        }

        function parseACF(text) {
            const lines = text.split(/\r?\n/);
            const objects = new Map(); // Index -> { file, pos: {}, rot: {} }

            lines.forEach(line => {
                line = line.trim();
                // We handle properties starting with P
                if (!line.startsWith('P ')) return;

                const parts = line.split(/\s+/);
                if (parts.length < 3) return; // P <path> <value>

                const keyPath = parts[1];
                const value = parts.slice(2).join(' ');

                // --- Global Properties (CG) ---
                // Metric V10+ (starts with acf/) or standard
                // Example: P acf/_cg_y_m 0.5
                // Example: P acf/_cgY 1.5
                if (keyPath.startsWith('acf/')) {
                    const prop = keyPath.substring(4); // Remove 'acf/'

                    if (prop === '_cg_x_m') {
                        acfCgOffset.x = parseFloat(value);
                    } else if (prop === '_cg_y_m') {
                        acfCgOffset.y = parseFloat(value);
                    } else if (prop === '_cg_z_m') {
                        acfCgOffset.z = parseFloat(value);
                    }
                    // Feet
                    else if (prop === '_cgX') {
                        acfCgOffset.x = parseFloat(value) * 0.3048;
                    } else if (prop === '_cgY') {
                        acfCgOffset.y = parseFloat(value) * 0.3048;
                    } else if (prop === '_cgZ') {
                        acfCgOffset.z = parseFloat(value) * 0.3048;
                    }
                }

                // --- Attached Objects (_obja) ---
                else if (keyPath.startsWith('_obja/')) {
                    const keyParts = keyPath.split('/');
                    if (keyParts.length < 3) return;

                    const index = parseInt(keyParts[1]);
                    if (isNaN(index)) return;

                    const prop = keyParts[2];

                    if (!objects.has(index)) {
                        objects.set(index, {
                            index: index,
                            file: null,
                            pos: { x: 0, y: 0, z: 0 },
                            rot: { phi: 0, theta: 0, psi: 0 }
                        });
                    }

                    const obj = objects.get(index);

                    if (prop === '_v10_att_file_stl') {
                        obj.file = value;
                    } else if (prop === '_v10_att_x_acf_prt_ref') {
                        obj.pos.x = parseFloat(value);
                    } else if (prop === '_v10_att_y_acf_prt_ref') {
                        obj.pos.y = parseFloat(value);
                    } else if (prop === '_v10_att_z_acf_prt_ref') {
                        obj.pos.z = parseFloat(value);
                    } else if (prop === '_v10_att_phi_ref') {
                        obj.rot.phi = parseFloat(value);
                    } else if (prop === '_v10_att_the_ref') {
                        obj.rot.theta = parseFloat(value);
                    } else if (prop === '_v10_att_psi_ref') {
                        obj.rot.psi = parseFloat(value);
                    }
                }
            });

            return Array.from(objects.values()).filter(o => o.file && o.file !== 'none' && o.file !== '-1');
        }

        // --- PARSER ---
        function parseOBJ8(text, fileName, displayName = null) {

            // Check if object exists and remove it to overwrite
            const existingIdx = loadedObjects.findIndex(o => o.name === fileName);
            if (existingIdx !== -1) {
                const oldRecord = loadedObjects[existingIdx];
                // Remove from scene & solo
                rootGroup.remove(oldRecord.group);

                // Cleanup animations and skeletons for this object
                animationControllers = animationControllers.filter(c => {
                    let curr = c.target;
                    while (curr) {
                        if (curr === oldRecord.group) return false;
                        curr = curr.parent;
                    }
                    return true;
                });

                skeletonHelpers = skeletonHelpers.filter(h => {
                    let curr = h;
                    while (curr) {
                        if (curr === oldRecord.group) return false;
                        curr = curr.parent;
                    }
                    return true;
                });

                if (oldRecord.group.geometry) oldRecord.group.geometry.dispose(); // Group doesn't have geometry but children do
                oldRecord.group.traverse(c => {
                    if (c.geometry) c.geometry.dispose();
                    // if (c.material) c.material.dispose(); // Managed by cache
                });

                // Remove/Replace UI
                // We'll actually just remove the old record and let subsequent code append new one.
                // Ideally we'd replace in place to keep order, but appending is safer for now.
                oldRecord.div.remove();
                loadedObjects.splice(existingIdx, 1);
                soloObjects.delete(oldRecord);
            } else {
                filesLoadedCount++;
            }

            const fileGroup = new THREE.Group();
            fileGroup.name = fileName;
            rootGroup.add(fileGroup);

            const lines = text.split(/\r?\n/);
            let currentTexture = "default";
            let litTexture = null;
            let normalTexture = null;
            let useNormalMetalness = false;

            // Pre-scan texture(s)
            for (let i = 0; i < Math.min(lines.length, 100); i++) {
                const l = lines[i].split('#')[0].trim();
                const parts = l.split(/\s+/);
                const cmd = parts[0];
                if (cmd === 'TEXTURE') { currentTexture = parts[1]; }
                if (cmd === 'TEXTURE_MAP' && parts.length > 2) {
                    const type = parts[1];
                    const file = parts[2];
                    if (type === 'albedo') currentTexture = file;
                    if (type === 'normal') normalTexture = file;
                    if (type === 'emissive') litTexture = file;
                }
                if (cmd === 'TEXTURE_LIT') { litTexture = parts[1]; }
                if (cmd === 'TEXTURE_NORMAL') { normalTexture = parts[1]; }
                if (cmd === 'NORMAL_METALNESS') { useNormalMetalness = true; }
            }

            // Register for List
            registerObjectUI(fileName, fileGroup, text, displayName, { currentTexture, litTexture, normalTexture });

            const vertices = [];
            const indices = [];

            let currentBlend = true;
            let currentPolyOS = 0;
            let currentDrawEnabled = true;
            let currentManip = null;

            const groupStack = [{ object: fileGroup }];
            const currentGroup = () => groupStack[groupStack.length - 1].object;
            let currentAnimKey = null;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].split('#')[0].trim();
                if (!line) continue;
                const tokens = line.split(/\s+/).filter(t => t.length > 0);
                const cmd = tokens[0];

                try {
                    if (cmd === 'VT') {
                        vertices.push({
                            x: parseFloat(tokens[1]) || 0, y: parseFloat(tokens[2]) || 0, z: parseFloat(tokens[3]) || 0,
                            nx: parseFloat(tokens[4]) || 0, ny: parseFloat(tokens[5]) || 0, nz: parseFloat(tokens[6]) || 0,
                            u: parseFloat(tokens[7]) || 0, v: parseFloat(tokens[8]) || 0
                        });
                    }
                    else if (cmd.startsWith('IDX')) {
                        for (let j = 1; j < tokens.length; j++) indices.push(parseInt(tokens[j]));
                    }
                    else if (cmd === 'TRIS') {
                        createMesh(tokens, vertices, indices, currentGroup, currentTexture, litTexture, normalTexture, useNormalMetalness, currentBlend, currentPolyOS, currentDrawEnabled, currentManip);
                    }
                    else if (cmd === 'ATTR_blend') {
                        currentBlend = true;
                    }
                    else if (cmd === 'ATTR_no_blend') {
                        currentBlend = false;
                    }
                    else if (cmd === 'ATTR_poly_os') {
                        currentPolyOS = parseInt(tokens[1]) || 0;
                    }
                    else if (cmd === 'ATTR_draw_enable') {
                        currentDrawEnabled = true;
                    }
                    else if (cmd === 'ATTR_draw_disable') {
                        currentDrawEnabled = false;
                    }
                    else if (cmd.startsWith('ATTR_manip_') || cmd === 'ATTR_axis_detented' || cmd === 'ATTR_axis_detent_range') {
                        if (cmd === 'ATTR_manip_none') {
                            currentManip = null;
                        } else if (cmd === 'ATTR_manip_noop') {
                            let dref = (tokens.length > 1) ? tokens[1] : 'N/A';
                            currentManip = { type: 'noop', dref: dref, tooltip: 'Clicks are swallowed' };
                        } else if (cmd === 'ATTR_manip_wheel') {
                            if (currentManip) currentManip.wheelDelta = tokens[1];
                        } else if (cmd === 'ATTR_manip_keyframe') {
                            if (currentManip) {
                                if (!currentManip.keyframes) currentManip.keyframes = [];
                                currentManip.keyframes.push({ val: tokens[1], angle: tokens[2] });
                            }
                        } else if (cmd === 'ATTR_axis_detented') {
                            if (currentManip) {
                                currentManip.detented = true;
                                if (tokens.length >= 7) currentManip.detentDref = tokens[6];
                            }
                        } else if (cmd === 'ATTR_axis_detent_range') {
                            if (currentManip) {
                                if (!currentManip.detentRanges) currentManip.detentRanges = [];
                                currentManip.detentRanges.push({ start: tokens[1], end: tokens[2], height: tokens[3] });
                            }
                        } else {
                            let type = cmd.replace('ATTR_manip_', '');
                            let dref = 'N/A';
                            let tooltip = '';
                            let isCommand = false;

                            switch (type) {
                                case 'drag_xy':
                                    if (tokens.length >= 10) dref = `${tokens[8]}, ${tokens[9]}`;
                                    if (tokens.length >= 11) tooltip = tokens.slice(10).join(' ');
                                    break;
                                case 'drag_axis':
                                    if (tokens.length >= 8) dref = tokens[7];
                                    if (tokens.length >= 9) tooltip = tokens.slice(8).join(' ');
                                    break;
                                case 'command':
                                    isCommand = true;
                                    if (tokens.length >= 3) dref = tokens[2];
                                    if (tokens.length >= 4) tooltip = tokens.slice(3).join(' ');
                                    break;
                                case 'command_axis':
                                    isCommand = true;
                                    if (tokens.length >= 7) dref = `${tokens[5]}, ${tokens[6]}`;
                                    if (tokens.length >= 8) tooltip = tokens.slice(7).join(' ');
                                    break;
                                case 'push':
                                    if (tokens.length >= 5) dref = tokens[4];
                                    if (tokens.length >= 6) tooltip = tokens.slice(5).join(' ');
                                    break;
                                case 'radio':
                                    if (tokens.length >= 4) dref = tokens[3];
                                    if (tokens.length >= 5) tooltip = tokens.slice(4).join(' ');
                                    break;
                                case 'toggle':
                                    if (tokens.length >= 5) dref = tokens[4];
                                    if (tokens.length >= 6) tooltip = tokens.slice(5).join(' ');
                                    break;
                                case 'delta':
                                case 'wrap':
                                    if (tokens.length >= 7) dref = tokens[6];
                                    if (tokens.length >= 8) tooltip = tokens.slice(7).join(' ');
                                    break;
                                case 'drag_axis_pix':
                                    if (tokens.length >= 8) dref = tokens[7];
                                    if (tokens.length >= 9) tooltip = tokens.slice(8).join(' ');
                                    break;
                                case 'command_knob':
                                case 'command_switch_up_down':
                                case 'command_switch_left_right':
                                    isCommand = true;
                                    if (tokens.length >= 4) dref = `${tokens[2]}, ${tokens[3]}`;
                                    if (tokens.length >= 5) tooltip = tokens.slice(4).join(' ');
                                    break;
                                case 'axis_knob':
                                case 'axis_switch_up_down':
                                case 'axis_switch_left_right':
                                    if (tokens.length >= 7) dref = tokens[6];
                                    if (tokens.length >= 8) tooltip = tokens.slice(7).join(' ');
                                    break;
                                case 'command_switch_left_right2':
                                case 'command_switch_up_down2':
                                case 'command_knob2':
                                    isCommand = true;
                                    if (tokens.length >= 3) dref = tokens[2];
                                    if (tokens.length >= 4) tooltip = tokens.slice(3).join(' ');
                                    break;
                                case 'drag_rotate':
                                    if (tokens.length >= 16) {
                                        dref = tokens[15];
                                        if (tokens.length >= 17 && tokens[16].toLowerCase() !== 'none') {
                                            dref += `, ${tokens[16]}`;
                                        }
                                    }
                                    if (tokens.length >= 18) tooltip = tokens.slice(17).join(' ');
                                    break;
                                case 'device':
                                    if (tokens.length >= 3) dref = tokens[2];
                                    if (tokens.length >= 4) tooltip = tokens.slice(3).join(' ');
                                    break;
                            }
                            currentManip = { type, dref, tooltip, isCommand };
                            // Also register datarefs so they appear in the GUI
                            if (dref !== 'N/A' && !isCommand) {
                                dref.split(/[,]/).forEach(d => registerDataRef(d.trim()));
                            }
                        }
                    }
                    else if (cmd === 'ANIM_begin') {
                        const g = new THREE.Group();
                        currentGroup().add(g);
                        groupStack.push({ object: g });
                    }
                    else if (cmd === 'ANIM_end') {
                        if (groupStack.length > 1) groupStack.pop();
                    }
                    else if (cmd === 'ANIM_trans') {
                        // ALWAYS APPLY STATIC TRANSFORMS
                        let isStatic = false;
                        if (tokens.length <= 4) isStatic = true;
                        else if (tokens.length >= 7 && !isNaN(parseFloat(tokens[6]))) {
                            const x1 = parseFloat(tokens[1]), x2 = parseFloat(tokens[4]);
                            if (Math.abs(x1 - x2) < 0.0001) isStatic = true;
                        }

                        if (isStatic) {
                            const wrapper = createWrapperGroup(groupStack);
                            let x = 0, y = 0, z = 0;
                            if (tokens.length >= 4) { x = parseFloat(tokens[1]); y = parseFloat(tokens[2]); z = parseFloat(tokens[3]); }
                            wrapper.position.set(x, y, z);
                            addSkeletonHelper(wrapper, 0xffff00, 0.05);
                        } else {
                            const wrapper = createWrapperGroup(groupStack);
                            const dref = tokens[tokens.length - 1];
                            const v1 = parseFloat(tokens[7]), v2 = parseFloat(tokens[8]);
                            const p1 = new THREE.Vector3(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3]));
                            const p2 = new THREE.Vector3(parseFloat(tokens[4]), parseFloat(tokens[5]), parseFloat(tokens[6]));
                            registerDataRef(dref, v1, v2);
                            animationControllers.push({ type: 'translate', target: wrapper, dref: dref, keys: [{ val: v1, pos: p1 }, { val: v2, pos: p2 }] });
                            addSkeletonHelper(wrapper, 0x00ff00, 0.1);
                        }
                    }
                    else if (cmd === 'ANIM_rotate') {
                        const lastToken = tokens[tokens.length - 1];
                        const isStatic = !isNaN(parseFloat(lastToken));
                        const axis = new THREE.Vector3(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3])).normalize();

                        if (isStatic) {
                            const wrapper = createWrapperGroup(groupStack);
                            const angle = parseFloat(tokens[4]);
                            wrapper.quaternion.setFromAxisAngle(axis, angle * (Math.PI / 180));
                            addSkeletonHelper(wrapper, 0xffaa00, 0.05);
                        } else {
                            const wrapper = createWrapperGroup(groupStack);
                            const dref = tokens[8];
                            const v1 = parseFloat(tokens[6]), v2 = parseFloat(tokens[7]);
                            registerDataRef(dref, v1, v2);
                            animationControllers.push({ type: 'rotate', target: wrapper, dref: dref, axis: axis, keys: [{ val: v1, angle: parseFloat(tokens[4]) }, { val: v2, angle: parseFloat(tokens[5]) }] });
                            addSkeletonHelper(wrapper, 0xff0000, 0.1);
                        }
                    }
                    else if (cmd === 'ANIM_hide' || cmd === 'ANIM_show') {
                        // Standard hide/show: v1 v2 dref
                        // If dref value is between v1 and v2, object is Hidden (ANIM_hide) or Shown (ANIM_show)
                        const wrapper = createWrapperGroup(groupStack);
                        const v1 = parseFloat(tokens[1]);
                        const v2 = parseFloat(tokens[2]);
                        const dref = tokens[3];
                        registerDataRef(dref, v1, v2);
                        animationControllers.push({
                            type: cmd === 'ANIM_hide' ? 'hide' : 'show',
                            target: wrapper,
                            dref: dref,
                            min: v1,
                            max: v2
                        });
                        addSkeletonHelper(wrapper, 0x555555, 0.05);
                    }
                    else if (cmd === 'ANIM_trans_begin') {
                        const dref = tokens[1]; // Might be undefined
                        currentAnimKey = {
                            type: 'translate',
                            dref: dref,
                            isStatic: !dref, // Flag as static if no DataRef
                            keys: [],
                            group: createWrapperGroup(groupStack)
                        };
                    }
                    else if (cmd === 'ANIM_rotate_begin') {
                        const axis = new THREE.Vector3(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3])).normalize();
                        const dref = tokens[4]; // Might be undefined
                        currentAnimKey = {
                            type: 'rotate',
                            dref: dref,
                            axis: axis,
                            isStatic: !dref, // Flag as static if no DataRef
                            keys: [],
                            group: createWrapperGroup(groupStack)
                        };
                        addSkeletonHelper(currentAnimKey.group, 0xff00ff, 0.1);
                    }
                    else if (cmd.endsWith('_key')) {
                        if (currentAnimKey) {
                            const val = parseFloat(tokens[1]);
                            // Only register DataRef if it exists (not static)
                            if (!currentAnimKey.isStatic) {
                                registerDataRef(currentAnimKey.dref, val);
                            }

                            if (currentAnimKey.type === 'translate') {
                                currentAnimKey.keys.push({
                                    val: val,
                                    pos: new THREE.Vector3(parseFloat(tokens[2]), parseFloat(tokens[3]), parseFloat(tokens[4]))
                                });
                            } else {
                                currentAnimKey.keys.push({
                                    val: val,
                                    angle: parseFloat(tokens[2])
                                });
                            }
                        }
                    }
                    else if (cmd.endsWith('_end')) {
                        if (currentAnimKey) {
                            if (currentAnimKey.isStatic) {
                                // STATIC: Calculate transform for default value 0 and apply immediately
                                // We assume input is 0 (standard default for un-driven animations)
                                const staticVal = interpolate(0, currentAnimKey.keys);

                                if (staticVal !== null) {
                                    if (currentAnimKey.type === 'translate') {
                                        currentAnimKey.group.position.copy(staticVal);
                                    } else if (currentAnimKey.type === 'rotate') {
                                        currentAnimKey.group.quaternion.setFromAxisAngle(
                                            currentAnimKey.axis,
                                            staticVal * (Math.PI / 180)
                                        );
                                    }
                                }
                                // We do NOT push to animationControllers, so it won't appear in the list
                            } else {
                                // DYNAMIC: Push to controllers
                                animationControllers.push({
                                    type: currentAnimKey.type,
                                    target: currentAnimKey.group,
                                    dref: currentAnimKey.dref,
                                    axis: currentAnimKey.axis,
                                    keys: currentAnimKey.keys
                                });
                            }
                            currentAnimKey = null;
                        }
                    }
                } catch (e) {
                    console.warn(`[OBJ8 Parser] Error in ${fileName} at line ${i + 1}: "${line}"`, e);
                }
            }
        }

        // --- MESH GENERATION ---
        function createMesh(tokens, vertices, indices, currentGroup, texName, litName, normName, useNormalMetalness, isTransparent, polyOS, drawEnabled, manipData) {
            const offset = parseInt(tokens[1]);
            const count = parseInt(tokens[2]);
            const geo = new THREE.BufferGeometry();
            const pos = [], norm = [], uv = [];

            for (let k = 0; k < count; k += 3) {
                // Invert face winding: 0, 2, 1
                const trip = [0, 2, 1];
                for (let t = 0; t < 3; t++) {
                    if (k + trip[t] >= count) continue;

                    let vIdx = offset + k + trip[t];
                    if (indices.length > 0) vIdx = (vIdx < indices.length) ? indices[vIdx] : 0;
                    if (vIdx < vertices.length) {
                        const v = vertices[vIdx];
                        pos.push(v.x, v.y, v.z);
                        norm.push(v.nx, v.ny, v.nz);
                        uv.push(v.u, v.v);
                    }
                }
            }
            if (pos.length > 0) {
                geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                geo.setAttribute('normal', new THREE.Float32BufferAttribute(norm, 3));
                geo.setAttribute('uv', new THREE.Float32BufferAttribute(uv, 2));

                // computeTangents requires position, normal, and uv. 
                // It also works better on indexed geometry.
                if (pos.length / 3 > 0) {
                    const tempIndices = [];
                    for (let n = 0; n < pos.length / 3; n++) tempIndices.push(n);
                    geo.setIndex(tempIndices);
                    geo.computeTangents();
                }

                const mat = getMaterial(texName, litName, normName, useNormalMetalness, isTransparent, polyOS);
                const mesh = new THREE.Mesh(geo, mat);
                mesh._textureName = texName;
                mesh._litName = litName;
                mesh._normalName = normName;
                mesh._useNormalMetalness = useNormalMetalness;
                mesh._isTransparent = isTransparent;
                mesh._polyOS = polyOS;
                mesh._drawEnabled = drawEnabled;
                mesh.visible = drawEnabled || (currentViewMode === 'manipulators') || settings.showDisabled;

                // Store Manipulator Data
                if (manipData) {
                    mesh.userData.manip = manipData;
                }

                // Handle Manipulator Mode View
                if (currentViewMode === 'manipulators') {
                    if (manipData) {
                        mesh.material = new THREE.MeshBasicMaterial({ color: 0x9c27b0, wireframe: false, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
                    } else {
                        mesh.material = new THREE.MeshBasicMaterial({ color: 0x333333, wireframe: true, transparent: true, opacity: 0.1 });
                    }
                }

                // Shadows removed
                currentGroup().add(mesh);
            }
        }

        function registerObjectUI(name, group, text, displayName = null, textures = {}) {
            const container = document.getElementById('obj-list-container');
            const div = document.createElement('div');
            div.className = 'obj-item';

            const nameSpan = document.createElement('span');
            nameSpan.className = 'obj-name';
            const display = displayName || name;

            let tooltip = `Object: ${display}`;
            if (textures.currentTexture && textures.currentTexture !== 'default') tooltip += `\nAlbedo: ${textures.currentTexture}`;
            if (textures.litTexture) tooltip += `\nLit: ${textures.litTexture}`;
            if (textures.normalTexture) tooltip += `\nNormal: ${textures.normalTexture}`;

            nameSpan.title = tooltip;
            nameSpan.textContent = display;

            const eye = document.createElement('span');
            eye.className = 'icon-btn eye-btn material-symbols-outlined';
            eye.textContent = 'visibility';
            eye.style.fontSize = '18px';

            const solo = document.createElement('span');
            solo.className = 'icon-btn solo-btn';
            solo.textContent = 'S';
            solo.title = 'Solo Object';

            const objRecord = { name, group, text, visible: true, div, eye, solo, datarefs: new Set() };
            loadedObjects.push(objRecord);

            // Toggle Visibility
            eye.onclick = (e) => {
                e.stopPropagation();
                if (soloObjects.size > 0) return; // Disable toggle when solo is active

                const newState = !objRecord.visible;

                // Identify if we should apply this to multiple objects
                const activeGroups = new Set();
                selectedMeshes.forEach(m => {
                    let curr = m;
                    while (curr && curr.parent !== rootGroup) curr = curr.parent;
                    if (curr) activeGroups.add(curr);
                });

                const recordsToToggle = [];
                if (activeGroups.has(objRecord.group)) {
                    // Clicked item is part of selection, toggle all selected objects
                    loadedObjects.forEach(rec => {
                        if (activeGroups.has(rec.group)) recordsToToggle.push(rec);
                    });
                } else {
                    // Clicked item is NOT selected, just toggle it
                    recordsToToggle.push(objRecord);
                }

                recordsToToggle.forEach(rec => {
                    rec.visible = newState;
                    rec.group.visible = newState;
                    rec.eye.textContent = newState ? 'visibility' : 'visibility_off';
                    rec.eye.classList.toggle('hidden', !newState);
                    rec.div.style.opacity = newState ? '1' : '0.5';
                });

                updateStats();
                updateDataRefVisibility();
            };

            // Solo Mode
            solo.onclick = (e) => {
                e.stopPropagation();

                // Toggle Solo Membership
                if (soloObjects.has(objRecord)) {
                    soloObjects.delete(objRecord);
                    solo.classList.remove('active');
                } else {
                    soloObjects.add(objRecord);
                    solo.classList.add('active');
                }

                updateVisibility(); // This function now handles Applying Visibility based on state
                updateDataRefVisibility();
            };

            // Selection
            div.onclick = (e) => {
                const index = loadedObjects.indexOf(objRecord);
                handleObjectListClick(index, e.shiftKey, e.ctrlKey || e.metaKey);
            };

            // Hover Highlight
            let boxHelper = null;
            div.onmouseenter = () => {
                div.classList.add('hover-active');
                boxHelper = new THREE.BoxHelper(group, 0xffff00);
                scene.add(boxHelper);
            };
            div.onmouseleave = () => {
                div.classList.remove('hover-active');
                if (boxHelper) scene.remove(boxHelper);
                boxHelper = null;
            };

            div.appendChild(nameSpan);
            div.appendChild(solo);
            div.appendChild(eye);
            container.appendChild(div);
        }

        // --- DATAREFS ---
        function registerDataRef(name, ...values) {
            if (!name) return;
            // Record in the most recently added object (the one currently being parsed)
            if (loadedObjects.length > 0) {
                loadedObjects[loadedObjects.length - 1].datarefs.add(name);
            }

            if (guiData[name] === undefined) {
                guiData[name] = 0;
            }

            let entry = datarefRanges.get(name);
            if (!entry) { entry = { min: Infinity, max: -Infinity }; datarefRanges.set(name, entry); }
            values.forEach(v => {
                if (v < entry.min) entry.min = v;
                if (v > entry.max) entry.max = v;
            });
        }

        function buildGUI() {
            // Instead of destroying everything, we rebuild the list properly
            // Clear existing UI references but keep guiData for state persistence
            [...gui.folders].forEach(f => f.destroy());
            [...gui.controllers].forEach(c => c.destroy());
            guiControllers = [];

            // Calculate Usage Counts (by number of meshes affected)
            const drefCounts = {};
            animationControllers.forEach(c => {
                if (c.dref) {
                    let meshCount = 0;
                    c.target.traverse(obj => {
                        if (obj.isMesh && !obj._isSelectionHelper) meshCount++;
                    });
                    drefCounts[c.dref] = (drefCounts[c.dref] || 0) + meshCount;
                }
            });

            const sortedKeys = Array.from(datarefRanges.keys()).sort();
            sortedKeys.forEach(name => {
                const range = datarefRanges.get(name);
                let min = range.min, max = range.max;
                let span = max - min;
                if (span === 0) span = 1;
                const margin = span * 0.05; // 10% total (5% each side)
                min -= margin; max += margin;

                // Ensure 0 is included in the range
                if (0 < min) min = -0.5;
                if (0 > max) max = 0.5;

                // 1. Collect Keyframes per DataRef
                const drefKeys = new Map();
                animationControllers.forEach(ctrl => {
                    if (ctrl.dref && ctrl.keys) {
                        if (!drefKeys.has(ctrl.dref)) drefKeys.set(ctrl.dref, new Set());
                        ctrl.keys.forEach(k => drefKeys.get(ctrl.dref).add(k.val));
                    }
                    // Also hide/show limits
                    if (ctrl.dref && (ctrl.type === 'hide' || ctrl.type === 'show')) {
                        if (!drefKeys.has(ctrl.dref)) drefKeys.set(ctrl.dref, new Set());
                        drefKeys.get(ctrl.dref).add(ctrl.min); // start
                        drefKeys.get(ctrl.dref).add(ctrl.max); // end
                    }
                });

                if (guiData[name] === undefined) {
                    guiData[name] = 0;
                }

                // Create Controller
                const ctrl = gui.add(guiData, name, min, max).name(name).listen();

                // Keyframe Snapping & Ticks
                const keys = drefKeys.has(name) ? Array.from(drefKeys.get(name)) : [];
                if (!keys.includes(0)) keys.push(0); // Ensure 0 is always a tick
                keys.sort((a, b) => a - b);

                // Inject Ticks
                if (keys.length > 0) {
                    // Wait for DOM to be ready
                    setTimeout(() => {
                        const widget = ctrl.domElement.querySelector('.widget');
                        const slider = widget ? widget.querySelector('.slider') : null;
                        if (slider) {
                            slider.style.position = 'relative'; // Ensure relative context
                            keys.forEach(k => {
                                // Calculate percent
                                const updateTick = (el, val) => {
                                    const currMin = ctrl._min;
                                    const currMax = ctrl._max;
                                    const pct = (val - currMin) / (currMax - currMin) * 100;
                                    el.style.left = pct + '%';
                                    el.style.display = (pct >= 0 && pct <= 100) ? 'block' : 'none';
                                };

                                const tick = document.createElement('div');
                                tick.style.position = 'absolute';
                                tick.style.top = '0';
                                tick.style.bottom = '0';
                                tick.style.width = '1px';
                                tick.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
                                tick.style.pointerEvents = 'none';
                                slider.appendChild(tick);

                                updateTick(tick, k);
                                // Attach update logic to controller so we can call it if range changes
                                if (!ctrl._ticks) ctrl._ticks = [];
                                ctrl._ticks.push({ el: tick, val: k });
                            });
                        }
                    }, 0);
                }

                // Snap Logic
                let isSnapping = false;
                ctrl.onChange(val => {
                    if (isSnapping) return;

                    // Disable snapping if manually typing (input is focused)
                    const input = ctrl.domElement.querySelector('input');
                    if (input === document.activeElement) return;

                    if (!isShiftDown && keys.length > 0) {
                        // Find nearest
                        let nearest = keys[0];
                        let minDiff = Math.abs(val - keys[0]);
                        for (let i = 1; i < keys.length; i++) {
                            const d = Math.abs(val - keys[i]);
                            if (d < minDiff) { minDiff = d; nearest = keys[i]; }
                        }

                        // Snap threshold: 2% of range
                        const threshold = (ctrl._max - ctrl._min) * 0.02;
                        if (minDiff < threshold) {
                            isSnapping = true;
                            ctrl.setValue(nearest);
                            isSnapping = false;
                            val = nearest;
                        }
                    }
                });

                // Allow out-of-bounds input values
                setTimeout(() => {
                    const input = ctrl.domElement.querySelector('input');
                    if (input) {
                        let rawInput = input.value;
                        input.addEventListener('input', (e) => { rawInput = e.target.value; });
                        input.addEventListener('change', () => {
                            const val = parseFloat(rawInput);
                            if (!isNaN(val)) {
                                guiData[name] = val;
                                ctrl.updateDisplay();
                            }
                        });
                    }
                }, 10);



                // Add click-to-copy button
                setTimeout(() => {
                    const nameEl = ctrl.domElement.querySelector('.name');
                    if (nameEl && !nameEl.querySelector('.copy-btn-inline')) {
                        const copyBtn = document.createElement('span');
                        copyBtn.className = 'material-symbols-outlined copy-btn-inline';
                        copyBtn.textContent = 'content_copy';
                        copyBtn.title = 'Copy DataRef';

                        copyBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            navigator.clipboard.writeText(name);
                            showToast(`Copied: ${name}`);
                        });

                        nameEl.prepend(copyBtn);

                        // Add selection logic when clicking the name
                        nameEl.addEventListener('click', () => {
                            selectMeshesByDataRef(name);
                        });
                    }
                    const inputs = ctrl.domElement.querySelectorAll('input, select');
                    inputs.forEach((input, idx) => {
                        if (!input.name) input.name = name;
                        if (!input.id) input.id = 'gui-' + name.replace(/\W/g, '-');
                    });
                }, 10);

                guiControllers.push({ name: name, controller: ctrl, count: (drefCounts[name] || 0) });
            });

            // Re-apply filter immediately after rebuild
            const searchVal = document.getElementById('dref-search').value;
            filterDataRefs({ target: { value: searchVal } });
        }

        function interpolate(val, keys) {
            if (keys.length === 0) return null;
            const first = keys[0];
            const last = keys[keys.length - 1];
            if (keys.length === 1) return first.pos ? first.pos.clone() : first.angle;

            let k1, k2;
            const isIncreasing = first.val < last.val;

            if (isIncreasing) {
                if (val <= first.val) {
                    k1 = keys[0]; k2 = keys[1];
                } else if (val >= last.val) {
                    k1 = keys[keys.length - 2]; k2 = keys[keys.length - 1];
                } else {
                    for (let i = 0; i < keys.length - 1; i++) {
                        if (val >= keys[i].val && val <= keys[i + 1].val) {
                            k1 = keys[i]; k2 = keys[i + 1]; break;
                        }
                    }
                }
            } else {
                if (val >= first.val) {
                    k1 = keys[0]; k2 = keys[1];
                } else if (val <= last.val) {
                    k1 = keys[keys.length - 2]; k2 = keys[keys.length - 1];
                } else {
                    for (let i = 0; i < keys.length - 1; i++) {
                        if (val <= keys[i].val && val >= keys[i + 1].val) {
                            k1 = keys[i]; k2 = keys[i + 1]; break;
                        }
                    }
                }
            }

            if (!k1 || !k2) return first.pos ? first.pos.clone() : first.angle;

            const t = (val - k1.val) / (k2.val - k1.val);
            if (k1.pos) return new THREE.Vector3().copy(k1.pos).lerp(k2.pos, t);
            return k1.angle + (k2.angle - k1.angle) * t;
        }

        function createWrapperGroup(stack) {
            const currentLevel = stack[stack.length - 1];
            const parent = currentLevel.object;
            const wrapper = new THREE.Group();
            parent.add(wrapper);
            currentLevel.object = wrapper;
            return wrapper;
        }

        const processedTextureCache = new Map();

        /**
         * Generic texture processor for X-Plane OBJ8 PBR workflows.
         * Handles MAT maps (R=Metal, G=Gloss) and NORMAL_METALNESS (B=Metal, A=Gloss).
         * @param {THREE.Texture} texture Source texture
         * @param {'mat'|'normal'|'normal_metalness'|'roughness_mat'|'metallic_mat'|'roughness_nm'|'metallic_nm'} type Processing mode
         */
        function getProcessedTexture(texture, type) {
            if (!texture || !texture.image || texture.isCanvasTexture) return texture;
            const cacheKey = `${texture.uuid}_${type}`;
            if (processedTextureCache.has(cacheKey)) return processedTextureCache.get(cacheKey);

            const img = texture.image;
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                if (type === 'mat') {
                    // X-Plane MAT: R=Metalness, G=Glossiness
                    const metal = data[i];
                    const gloss = data[i + 1];
                    data[i + 2] = metal;          // Metalness -> Blue
                    data[i + 1] = 255 - gloss;    // Roughness -> Green (1-Gloss)
                    data[i] = 255;                // Red unused
                }
                else if (type === 'normal_metalness') {
                    // X-Plane NORMAL_METALNESS: B=Metalness, A=Glossiness
                    const metal = data[i + 2];
                    const gloss = data[i + 3];
                    data[i + 2] = metal;          // Metalness -> Blue
                    data[i + 1] = 255 - gloss;    // Roughness -> Green (1-Gloss)
                    data[i] = 255;                // Red unused
                }
                else if (type === 'normal') {
                    // Clean Blue channel if it might contain Metalness data
                    data[i + 2] = 255;
                }
                else if (type === 'roughness_mat') {
                    const gloss = data[i + 1];
                    data[i] = data[i + 1] = data[i + 2] = 255 - gloss;
                }
                else if (type === 'metallic_mat') {
                    const metal = data[i];
                    data[i] = data[i + 1] = data[i + 2] = metal;
                }
                else if (type === 'roughness_nm') {
                    const gloss = data[i + 3];
                    data[i] = data[i + 1] = data[i + 2] = 255 - gloss;
                }
                else if (type === 'metallic_nm') {
                    const metal = data[i + 2];
                    data[i] = data[i + 1] = data[i + 2] = metal;
                }
                data[i + 3] = 255; // Ensure full opacity
            }

            ctx.putImageData(imageData, 0, 0);
            const newTex = new THREE.CanvasTexture(canvas);
            newTex.name = `${texture.name}_${type}`;
            newTex.colorSpace = THREE.NoColorSpace;
            ['flipY', 'wrapS', 'wrapT', 'minFilter', 'magFilter'].forEach(p => newTex[p] = texture[p]);

            processedTextureCache.set(cacheKey, newTex);
            return newTex;
        }

        function getMaterial(textureName, litName, normalName, useNormalMetalness, isTransparent, polyOS = 0) {
            const baseName = textureName ? textureName.split(/[/\\]/).pop() : "default";
            const litBase = litName ? litName.split(/[/\\]/).pop() : null;
            const normBase = normalName ? normalName.split(/[/\\]/).pop() : null;
            const cacheKey = `${baseName}|${litBase}|${normBase}|${currentViewMode}|${useNormalMetalness}|${isTransparent}|${polyOS}`;

            if (!materialCache.has(cacheKey)) {
                let mat;
                const standardProps = {
                    side: THREE.FrontSide,
                    transparent: false,
                    alphaToCoverage: isTransparent,
                    polygonOffset: polyOS !== 0,
                    polygonOffsetFactor: -polyOS,
                    polygonOffsetUnits: -polyOS
                };

                if (['albedo', 'lit_only', 'roughness', 'metallic'].includes(currentViewMode)) {
                    mat = new THREE.MeshBasicMaterial({ color: 0xffffff, ...standardProps });
                } else if (currentViewMode === 'normals') {
                    mat = new THREE.MeshNormalMaterial(standardProps);
                } else {
                    mat = new THREE.MeshStandardMaterial({
                        name: baseName,
                        color: 0xbbbbbb,
                        roughness: settings.rough,
                        metalness: settings.metal,
                        envMapIntensity: settings.envIntensity,
                        ...standardProps
                    });
                    if (currentViewMode === 'wireframe') mat.wireframe = true;
                }

                const findTex = (name) => {
                    if (!name || name === "default") return null;
                    const low = name.toLowerCase();
                    const candidates = [
                        low, low + ".png", low + ".jpg", low + ".jpeg", low + ".bmp", low + ".dds",
                        low.replace(/\.[^/.]+$/, "") + ".png",
                        low.replace(/\.[^/.]+$/, "") + ".jpg",
                        low.replace(/\.[^/.]+$/, "") + ".dds"
                    ];
                    for (const c of candidates) if (loadedTextures.has(c)) return loadedTextures.get(c);
                    return null;
                };

                if (['material', 'solid', 'wireframe', 'normals'].includes(currentViewMode)) {
                    // 1. Albedo & Lit (Only for non-normals modes)
                    if (['material', 'solid', 'wireframe'].includes(currentViewMode)) {
                        if (currentViewMode === 'material') {
                            const tex = findTex(baseName);
                            if (tex) { mat.map = tex; mat.color.set(0xffffff); }
                            const ltex = findTex(litBase);
                            if (ltex) { mat.emissiveMap = ltex; mat.emissive.set(0xffffff); mat.emissiveIntensity = settings.lit; }
                        } else {
                            mat.color.set(0x888888);
                        }
                    }

                    // 2. Normals & PBR
                    const rootName = baseName.replace(/\.[^/.]+$/, "").replace(/_alb$/i, "");
                    let ntex = findTex(normBase) || findTex(rootName + "_NRM") || findTex(rootName + "_nrm");

                    if (ntex) {
                        mat.normalMap = useNormalMetalness ? getProcessedTexture(ntex, 'normal') : ntex;
                        mat.normalScale.set(1, 1);
                        ntex.colorSpace = THREE.NoColorSpace;
                    }

                    // 3. PBR Maps (MAT or NORMAL_METALNESS) - Only for standard materials
                    if (mat.isMeshStandardMaterial) {
                        const mtex = findTex(rootName + "_MAT") || findTex(rootName + "_mat");
                        if (mtex) {
                            const pTex = getProcessedTexture(mtex, 'mat');
                            mat.metalnessMap = mat.roughnessMap = pTex;
                            mat.metalness = mat.roughness = 1.0;
                        } else if (useNormalMetalness && ntex) {
                            const pTex = getProcessedTexture(ntex, 'normal_metalness');
                            mat.metalnessMap = mat.roughnessMap = pTex;
                            mat.metalness = mat.roughness = 1.0;
                        }
                        if (!mat.map && (mtex || (useNormalMetalness && ntex))) mat.color.set(0xffffff);
                    }

                } else if (currentViewMode === 'albedo') {
                    const tex = findTex(baseName);
                    if (tex) mat.map = tex;
                } else if (currentViewMode === 'lit_only') {
                    const ltex = findTex(litBase);
                    if (ltex) mat.map = ltex; else mat.color.set(0x000000);
                } else if (currentViewMode === 'roughness' || currentViewMode === 'metallic') {
                    const rootName = baseName.replace(/\.[^/.]+$/, "").replace(/_alb$/i, "");
                    const ntex = findTex(normBase) || findTex(rootName + "_NRM") || findTex(rootName + "_nrm");
                    const mtex = findTex(rootName + "_MAT") || findTex(rootName + "_mat");

                    if (currentViewMode === 'roughness') {
                        if (mtex) {
                            mat.map = getProcessedTexture(mtex, 'roughness_mat');
                        } else if (useNormalMetalness && ntex) {
                            mat.map = getProcessedTexture(ntex, 'roughness_nm');
                        } else {
                            const val = settings.rough;
                            mat.color.setRGB(val, val, val);
                        }
                    } else { // metallic
                        if (mtex) {
                            mat.map = getProcessedTexture(mtex, 'metallic_mat');
                        } else if (useNormalMetalness && ntex) {
                            mat.map = getProcessedTexture(ntex, 'metallic_nm');
                        } else {
                            const val = settings.metal;
                            mat.color.setRGB(val, val, val);
                        }
                    }
                }

                materialCache.set(cacheKey, mat);
            }
            return materialCache.get(cacheKey);
        }

        function updateMaterialProperties() {
            // Efficiently update existing materials without rebuilding them
            // This assumes all materials in cache are active or valid
            materialCache.forEach(mat => {
                // Shared logic for Material/Standard modes
                if (mat.isMeshStandardMaterial) {
                    // Update envMapIntensity
                    mat.envMapIntensity = settings.envIntensity;

                    // Update LIT intensity if map exists
                    if (mat.emissiveMap) {
                        mat.emissiveIntensity = settings.lit;
                    }

                    // Update Roughness/Metalness ONLY if no maps are defining them
                    // (Matches logic in getMaterial where we set to 1.0 if map exists)
                    if (!mat.roughnessMap) {
                        mat.roughness = settings.rough;
                    }
                    if (!mat.metalnessMap) {
                        mat.metalness = settings.metal;
                    }
                }
            });
        }

        function refreshMaterials() {
            // Clear cache so we really fetch potentially new textures
            materialCache.clear();

            // Materials for Manipulator Mode
            const manipMat = new THREE.MeshBasicMaterial({ color: 0x9c27b0, wireframe: false, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
            const nonManipMat = new THREE.MeshBasicMaterial({ color: 0x333333, wireframe: true, transparent: true, opacity: 0.1 });

            rootGroup.traverse(obj => {
                if (obj.isMesh && !obj._isSelectionHelper) {
                    // Skip VR Hotspot system objects - they manage their own materials
                    if (obj.userData.isSystem || obj.userData.isVRHotspot) return;

                    if (currentViewMode === 'manipulators') {
                        obj.material = obj.userData.manip ? manipMat : nonManipMat;
                    } else {
                        const t = obj._textureName, l = obj._litName, n = obj._normalName, m = obj._useNormalMetalness, tr = obj._isTransparent, pos = obj._polyOS;
                        obj.material = getMaterial(t, l, n, m, tr, pos);
                    }
                }
            });
        }

        function refreshAllObjects() {
            // Store records because parseOBJ8 will remove them from loadedObjects and re-add them
            const records = [...loadedObjects];
            records.forEach(rec => {
                parseOBJ8(rec.text, rec.name);
            });
        }

        async function checkLiveReload() {
            if (!settings.live) return;

            const filesToReload = [];

            for (const [name, info] of fileHandleMap.entries()) {
                try {
                    if (info.isDirectory) {
                        // For directories, check all children that we care about
                        for await (const entry of info.handle.values()) {
                            if (entry.kind === 'file') {
                                const file = await entry.getFile();
                                // Only reload if it's a file we've already tracked or is an OBJ/Texture
                                const isRelevant = /\.(obj|png|jpg|jpeg|bmp|dds|hdr)$/i.test(file.name) || file.name.toLowerCase().includes('_vrconfig.txt');
                                if (isRelevant) {
                                    const tracked = fileHandleMap.get(file.name);
                                    if (!tracked || file.lastModified !== tracked.lastModified || file.size !== tracked.size) {
                                        // Preserve sceneName if it exists
                                        fileHandleMap.set(file.name, {
                                            handle: entry,
                                            lastModified: file.lastModified,
                                            size: file.size,
                                            sceneName: tracked?.sceneName // Preserve original scene name
                                        });
                                        filesToReload.push(file);
                                    }
                                }
                            }
                        }
                    } else {
                        // Individual file handle check
                        const file = await info.handle.getFile();
                        if (file.lastModified !== info.lastModified || file.size !== info.size) {
                            // Preserve sceneName when updating
                            info.lastModified = file.lastModified;
                            info.size = file.size;
                            // sceneName is already in info, no need to update
                            filesToReload.push(file);
                        }
                    }
                } catch (err) {
                    // This can happen if a file is replaced (deleted and recreated)
                    // If we have its parent directory tracked, the directory loop above will re-acquire it.
                    // Otherwise, we notify that the link might be broken.
                    if (!info.errorLogged) {
                        console.warn(`Live link lost for ${name}. If you replaced the file, try dragging the parent folder instead for better stability.`, err);
                        info.errorLogged = true;
                    }
                }
            }

            if (filesToReload.length > 0) {
                console.log(`Live Reloading ${filesToReload.length} file(s)...`);

                // Separate VR config files from other files
                const vrConfigFiles = filesToReload.filter(f => f.name.toLowerCase().includes('_vrconfig.txt'));
                const otherFiles = filesToReload.filter(f => !f.name.toLowerCase().includes('_vrconfig.txt'));

                // Reload VR config files
                for (const file of vrConfigFiles) {
                    try {
                        const text = await file.text();
                        const result = parseVRConfig(text);
                        if (result.hotspots.length > 0) {
                            drawHotspots(result);
                        }
                        console.log(`Reloaded VR config: ${file.name}`);
                    } catch (e) {
                        console.error("Error reloading VR config:", e);
                    }
                }

                // Reload other files (OBJ, textures)
                if (otherFiles.length > 0) {
                    await processFiles(otherFiles, true);
                }

                showUpdateNotification(filesToReload);
            }
        }

        function addSkeletonHelper(group, color, size) {
            const axes = new THREE.AxesHelper(size);
            group.add(axes);
            const visible = document.getElementById('toggle-skeleton-btn').classList.contains('active');
            axes.visible = visible;
            skeletonHelpers.push(axes);
        }

        function updateStats(group = null) {
            let vTotal = 0, tTotal = 0;
            let vSel = 0, tSel = 0;
            let oTotal = 0, oSel = 0;

            let dRefs = new Set();
            let aCount = 0;

            if (group) {
                // Stats for specific object/group override? 
                // User asked for "Selected / Total". 
                // Hover stats might just show that object's stats?
                // Let's stick to global stats for now to meet the "like Blender" requirement 
                // but maybe we can just compute global here every time.
            }

            // 1. Calculate Visible Totals
            loadedObjects.forEach(obj => {
                if (obj.group.visible) {
                    oTotal++;
                    obj.group.traverse(o => {
                        if (o.isMesh && !o._isSelectionHelper) {
                            vTotal += o.geometry.attributes.position.count;
                            if (o.geometry.index) {
                                tTotal += o.geometry.index.count / 3;
                            } else {
                                tTotal += o.geometry.attributes.position.count / 3;
                            }
                        }
                    });
                }
            });

            // 2. Calculate Selected Totals
            if (selectedMeshes.length > 0) {
                // Count unique top-level objects selected
                let uniqueSelObjs = new Set();
                selectedMeshes.forEach(m => {
                    let curr = m;
                    // Traverse up to find the root object (child of rootGroup)
                    while (curr && curr.parent !== rootGroup) {
                        curr = curr.parent;
                    }
                    if (curr && curr.name) { // Ensure it's one of our loaded objects
                        uniqueSelObjs.add(curr);
                    }
                });

                oSel = uniqueSelObjs.size;

                // For verts/tris, we still sum up the actual selected MESHES because in Object Mode in Blender, 
                // selecting an object implies selecting all its geometry stats. 
                // However, our selection is mesh-based (raycast).
                // If the user wants "Object" stats, we should probably verify if we are in "Object Mode" or "Edit Mode" equivalent.
                // Assuming "Object Mode" equivalent: 
                // If I select a mesh part of an airplane, I probably consider the "Airplane" selected?
                // Or does the user mean "only the vertices of the selected mesh"?
                // "Stats should display the selected mesh not object" -> likely means specific mesh stats.
                // BUT "Stats should display the selected mesh not object" implies counting the mesh itself?
                // Wait, "Selected / Total" usually refers to Object count.
                // Let's stick to summing selected mesh geometry for V/T, and top-level objects for O.

                selectedMeshes.forEach(m => {
                    vSel += m.geometry.attributes.position.count;
                    if (m.geometry.index) {
                        tSel += m.geometry.index.count / 3;
                    } else {
                        tSel += m.geometry.attributes.position.count / 3;
                    }
                });
            }

            // 3. DataRefs and Anims (Global)
            animationControllers.forEach(ctrl => {
                aCount++;
                if (ctrl.dref) dRefs.add(ctrl.dref);
            });

            const format = (n) => n.toLocaleString();

            document.getElementById('v-count').innerText = `${format(vSel)} / ${format(vTotal)}`;
            document.getElementById('m-count').innerText = `${format(tSel)} / ${format(tTotal)}`;
            document.getElementById('o-count').innerText = `${format(oSel)} / ${format(oTotal)}`;
            document.getElementById('d-count').innerText = format(dRefs.size);
            document.getElementById('a-count').innerText = format(aCount);
        }

        function centerCamera() {
            if (rootGroup.children.length === 0) return;

            // Force update of all world matrices before computing bounds
            rootGroup.updateMatrixWorld(true);

            const box = new THREE.Box3();
            let hasBounds = false;

            if (selectedMeshes.length > 0) {
                // Center on selection
                selectedMeshes.forEach(m => {
                    m.geometry.computeBoundingBox();
                    const b = new THREE.Box3().copy(m.geometry.boundingBox).applyMatrix4(m.matrixWorld);
                    box.union(b);
                });
                hasBounds = true;
            } else {
                // Center on all visible meshes (excluding selection helpers)
                rootGroup.traverse(obj => {
                    if (obj.isMesh && !obj._isSelectionHelper) {
                        // Check if object and all ancestors (up to rootGroup) are visible
                        let curr = obj;
                        let visible = true;
                        while (curr && curr !== scene) {
                            if (!curr.visible) {
                                visible = false;
                                break;
                            }
                            curr = curr.parent;
                        }

                        if (visible) {
                            obj.geometry.computeBoundingBox();
                            const meshBox = new THREE.Box3().copy(obj.geometry.boundingBox).applyMatrix4(obj.matrixWorld);
                            box.union(meshBox);
                            hasBounds = true;
                        }
                    }
                });
            }

            if (!hasBounds || box.isEmpty()) return;

            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());

            // Calculate distance needed to fit the box in both horizontal and vertical FOV
            const maxDim = Math.max(size.x, size.y, size.z);
            if (isNaN(maxDim) || maxDim <= 0) return;

            // Account for both vertical and horizontal FOV
            const fov = camera.fov * (Math.PI / 180);
            const aspect = camera.aspect;

            // Calculate required distance for vertical FOV
            const distanceV = (size.y / 2) / Math.tan(fov / 2);

            // Calculate required distance for horizontal FOV
            const fovH = 2 * Math.atan(Math.tan(fov / 2) * aspect);
            const distanceH = (size.x / 2) / Math.tan(fovH / 2);

            // Use the larger distance to ensure everything fits
            let distance = Math.max(distanceV, distanceH, size.z / 2);

            // Add 40% padding for better framing with more margin
            distance *= 1.4;

            // Ensure minimum distance
            distance = Math.max(distance, 0.5);

            // Preserve current orientation relative to the new target
            const currentDir = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();

            // If currentDir is zero length (e.g. camera inside target), fallback to default
            if (currentDir.lengthSq() < 0.0001) {
                currentDir.set(1, 0.8, 1).normalize();
            }

            const offset = currentDir.multiplyScalar(distance);
            camera.position.copy(center).add(offset);

            controls.target.copy(center);
            controls.update();
        }

        function takeScreenshot() {
            // 1. Check Hardware Limits
            const gl = renderer.getContext();
            const maxViewportDims = gl.getParameter(gl.MAX_VIEWPORT_DIMS);
            const maxRes = Math.min(maxViewportDims[0], maxViewportDims[1], 16384);

            // 2. Save current state
            const originalBackground = scene.background;
            const originalGridVisible = worldGrid.visible;
            const originalAxesVisible = worldAxes.visible;
            const skeletonStates = skeletonHelpers.map(h => h.visible);

            const originalSize = new THREE.Vector2();
            renderer.getSize(originalSize);
            const originalPixelRatio = renderer.getPixelRatio();
            const originalClearAlpha = renderer.getClearAlpha();

            // 3. Calculate and Validate Resolution
            const screenshotMultiplier = settings.ssMultiplier || 1;
            let width = Math.round(originalSize.x * screenshotMultiplier);
            let height = Math.round(originalSize.y * screenshotMultiplier);

            if (width > maxRes || height > maxRes) {
                const ratio = Math.min(maxRes / width, maxRes / height);
                width = Math.floor(width * ratio);
                height = Math.floor(height * ratio);
                showToast(`Resolution capped to ${width}x${height}`);
            }

            // 4. Prepare for render
            renderer.setSize(width, height, false);
            renderer.setViewport(0, 0, width, height);

            // Background Logic
            if (settings.ssBgMode === 'transparent') {
                scene.background = null;
                renderer.setClearAlpha(0);
            } else if (settings.ssBgMode === 'gradient') {
                const canvas = document.createElement('canvas');
                canvas.width = 2;
                canvas.height = 512;
                const ctx = canvas.getContext('2d');
                const grad = ctx.createLinearGradient(0, 0, 0, 512);
                grad.addColorStop(0, settings.ssBgColor1 || '#1e1e1e');
                grad.addColorStop(1, settings.ssBgColor2 || '#050505');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, 2, 512);
                const tex = new THREE.CanvasTexture(canvas);
                tex.colorSpace = THREE.SRGBColorSpace;
                scene.background = tex;
            } else {
                // Solid Mode
                scene.background = new THREE.Color(settings.ssBgColor1 || 0x121212);
                renderer.setClearAlpha(1);
            }

            // Hide UI helpers
            worldGrid.visible = false;
            worldAxes.visible = false;
            skeletonHelpers.forEach(h => h.visible = false);
            const selectedHelpers = [];
            rootGroup.traverse(obj => {
                if (obj._isSelectionHelper) {
                    selectedHelpers.push({ obj, visible: obj.visible });
                    obj.visible = false;
                }
            });

            // 5. Render and Capture
            try {
                renderer.render(scene, camera);

                renderer.domElement.toBlob((blob) => {
                    if (!blob) {
                        showToast("Capture failed");
                        restore();
                        return;
                    }
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                    link.download = `screenshot_${width}x${height}_${timestamp}.png`;
                    link.href = url;
                    link.click();
                    URL.revokeObjectURL(url);
                    restore();
                }, 'image/png');

            } catch (e) {
                console.error("Screenshot failed:", e);
                showToast("Screenshot failed");
                restore();
            }

            function restore() {
                renderer.setSize(originalSize.x, originalSize.y, true);
                renderer.setPixelRatio(originalPixelRatio);
                renderer.setViewport(0, 0, originalSize.x, originalSize.y);

                scene.background = originalBackground;
                renderer.setClearAlpha(originalClearAlpha);
                worldGrid.visible = originalGridVisible;
                worldAxes.visible = originalAxesVisible;
                skeletonHelpers.forEach((h, i) => h.visible = skeletonStates[i]);
                selectedHelpers.forEach(s => s.obj.visible = s.visible);

                renderer.render(scene, camera);
            }
        }

        function filterDataRefs(e) {
            updateDataRefVisibility();
        }

        function updateDataRefVisibility() {
            const searchInput = document.getElementById('dref-search');
            const term = searchInput.value.toLowerCase();

            // Determine active datarefs based on visibility AND potential selection
            const activeDatarefs = new Set();

            if (selectedMeshes.length > 0) {
                searchInput.placeholder = "Filtered by selection...";
                // Only show datarefs relevant to these specific meshes and their parents
                selectedMeshes.forEach(mesh => {
                    let curr = mesh;
                    while (curr && curr !== rootGroup && curr !== scene) {
                        for (let ctrl of animationControllers) {
                            if (ctrl.target === curr && ctrl.dref) {
                                activeDatarefs.add(ctrl.dref);
                            }
                        }
                        curr = curr.parent;
                    }
                });
            } else if (lastVisibilityMap !== null) {
                searchInput.placeholder = "Filtered by isolation...";
                // Isolation mode: only show datarefs for meshes that are currently visible
                rootGroup.traverse(o => {
                    if (o.isMesh && o.visible && !o._isSelectionHelper) {
                        let curr = o;
                        while (curr && curr !== rootGroup && curr !== scene) {
                            for (let ctrl of animationControllers) {
                                if (ctrl.target === curr && ctrl.dref) {
                                    activeDatarefs.add(ctrl.dref);
                                }
                            }
                            curr = curr.parent;
                        }
                    }
                });
            } else {
                searchInput.placeholder = "Filter DataRefs...";
                // Normal mode: Show Union of all DataRefs used by currently visible objects
                loadedObjects.forEach(obj => {
                    if (obj.group.visible) {
                        obj.datarefs.forEach(d => activeDatarefs.add(d));
                    }
                });
            }

            // Separate active and inactive items for sorting
            const activeItems = [];
            const inactiveItems = [];

            guiControllers.forEach(item => {
                const isMatch = item.name.toLowerCase().includes(term);
                const isActive = activeDatarefs.has(item.name);
                const isVisible = isMatch && isActive;

                if (isVisible) {
                    item.controller.domElement.style.display = '';
                    activeItems.push(item);
                } else {
                    item.controller.domElement.style.display = 'none';
                    inactiveItems.push(item);
                }
            });

            // Sort active items: Least usage first, then alphabetical
            activeItems.sort((a, b) => {
                if (a.count !== b.count) return a.count - b.count;
                return a.name.localeCompare(b.name);
            });

            // Re-order DOM
            if (guiControllers.length > 0) {
                const container = guiControllers[0].controller.domElement.parentElement;
                if (container) {
                    // Append active ones in order
                    activeItems.forEach(item => container.appendChild(item.controller.domElement));
                    // Append inactive ones (keeps them in the DOM but hidden)
                    inactiveItems.forEach(item => container.appendChild(item.controller.domElement));
                }
            }
        }

        function showUpdateNotification(files) {
            const container = document.getElementById('notification-container');
            const toast = document.createElement('div');
            toast.className = 'update-toast';

            const icon = document.createElement('span');
            icon.className = 'material-symbols-outlined';
            icon.textContent = 'sync';

            const text = document.createElement('span');
            if (files.length === 1) {
                text.textContent = `Updated: ${files[0].name}`;
            } else {
                text.textContent = `${files.length} files updated`;
            }

            toast.appendChild(icon);
            toast.appendChild(text);
            container.appendChild(toast);

            // Remove after animation finishes
            setTimeout(() => toast.remove(), 5500);
        }

        function showToast(msg) {
            const toast = document.createElement('div');
            toast.className = 'copy-toast';
            toast.textContent = msg;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 2000);
        }

        function onResize() {
            const vp = document.getElementById('viewport');
            camera.aspect = vp.clientWidth / vp.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(vp.clientWidth, vp.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // WASD Movement
            if (keyState.w || keyState.s || keyState.a || keyState.d || keyState.q || keyState.e) {
                // Calculate Speed - dynamic based on distance to target or fixed?
                // Fixed is safer for "fly" mode usually, but scene scale varies.
                // Let's use a base speed scaled by shift.
                const speed = isShiftDown ? moveSpeed * 5 : moveSpeed;

                const dir = new THREE.Vector3();
                camera.getWorldDirection(dir);

                const right = new THREE.Vector3();
                right.crossVectors(dir, camera.up).normalize();

                const moveVec = new THREE.Vector3();

                if (keyState.w) moveVec.add(dir);
                if (keyState.s) moveVec.sub(dir);
                if (keyState.d) moveVec.add(right);
                if (keyState.a) moveVec.sub(right);
                if (keyState.e) moveVec.add(camera.up); // Fly Up (World Up)
                if (keyState.q) moveVec.sub(camera.up); // Fly Down

                if (moveVec.lengthSq() > 0) {
                    moveVec.normalize().multiplyScalar(speed);
                    camera.position.add(moveVec);
                    controls.target.add(moveVec);
                }
            }

            controls.update();
            for (const ctrl of animationControllers) {
                const val = guiData[ctrl.dref];
                if (val === undefined) continue;
                if (ctrl.type === 'translate') ctrl.target.position.copy(interpolate(val, ctrl.keys));
                else if (ctrl.type === 'rotate') ctrl.target.quaternion.setFromAxisAngle(ctrl.axis, interpolate(val, ctrl.keys) * (Math.PI / 180));
                else if (ctrl.type === 'hide') {
                    if (isSpaceDown) ctrl.target.visible = true;
                    else {
                        if (ctrl.min <= ctrl.max) {
                            ctrl.target.visible = !(val >= ctrl.min && val <= ctrl.max);
                        } else {
                            // Reversed: hide if outside [max, min], i.e., show if inside (max, min)
                            ctrl.target.visible = (val > ctrl.max && val < ctrl.min);
                        }
                    }
                }
                else if (ctrl.type === 'show') {
                    if (isSpaceDown) ctrl.target.visible = true;
                    else {
                        if (ctrl.min <= ctrl.max) {
                            ctrl.target.visible = (val >= ctrl.min && val <= ctrl.max);
                        } else {
                            // Reversed: show if outside [max, min]
                            ctrl.target.visible = (val <= ctrl.max || val >= ctrl.min);
                        }
                    }
                }
            }
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>

</html>